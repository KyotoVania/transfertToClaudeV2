--- App.tsx ---
import { Canvas } from '@react-three/fiber'
import { OrbitControls, Stats } from '@react-three/drei'
import { Suspense, useRef, useEffect } from 'react'
import { useAudioAnalyzer } from './hooks/useAudioAnalyzer'
import { useConfigStore } from './store/configStore'
import { VisualizationRenderer } from './scenes/VisualizationRenderer'
import { ConfigPanel } from './components/ConfigPanel'

function App() {
  const audioRef = useRef<HTMLAudioElement>(null)
  const audioData = useAudioAnalyzer(audioRef.current || undefined)
  const { global: globalConfig } = useConfigStore()
  const currentUrlRef = useRef<string | null>(null)

  // Add logging for BPM detection and harmony analysis
  useEffect(() => {
    if (audioData.rhythmicFeatures.bpm > 0) {
      console.log('üéµ BPM Detection:', {
        bpm: audioData.rhythmicFeatures.bpm,
        confidence: audioData.rhythmicFeatures.bpmConfidence,
        beatPhase: audioData.rhythmicFeatures.beatPhase,
        subdivision: audioData.rhythmicFeatures.subdivision,
        groove: audioData.rhythmicFeatures.groove
      })
    }

    if (audioData.melodicFeatures.dominantNote !== 'N/A') {
      console.log('üéº Harmony Analysis:', {
        dominantNote: audioData.melodicFeatures.dominantNote,
        frequency: audioData.melodicFeatures.dominantFrequency.toFixed(2) + ' Hz',
        confidence: audioData.melodicFeatures.noteConfidence.toFixed(3),
        harmonicContent: audioData.melodicFeatures.harmonicContent.toFixed(3),
        pitchClass: audioData.melodicFeatures.pitchClass.map(v => v.toFixed(3))
      })
    }

    if (audioData.spectralFeatures.centroid > 0) {
      console.log('üéõÔ∏è Spectral Features:', {
        centroid: audioData.spectralFeatures.centroid.toFixed(3),
        spread: audioData.spectralFeatures.spread.toFixed(3),
        flux: audioData.spectralFeatures.flux.toFixed(3),
        rolloff: audioData.spectralFeatures.rolloff.toFixed(3)
      })
    }
  }, [
    audioData.rhythmicFeatures.bpm,
    audioData.melodicFeatures.dominantNote,
    audioData.spectralFeatures.centroid
  ])

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file && audioRef.current) {
      // Clean up previous URL
      if (currentUrlRef.current) {
        URL.revokeObjectURL(currentUrlRef.current)
      }

      const url = URL.createObjectURL(file)
      currentUrlRef.current = url
      audioRef.current.src = url
    }
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (currentUrlRef.current) {
        URL.revokeObjectURL(currentUrlRef.current)
      }
    }
  }, [])

  return (
    <div style={{ width: '100vw', height: '100vh', position: 'relative', background: '#000' }}>
      <Canvas
        camera={{
          position: [0, 8, 15],
          fov: globalConfig.cameraFOV,
        }}
        dpr={[1, 2]}
        gl={{ antialias: true }}
      >
        <color attach="background" args={[globalConfig.bgColor]} />

        <Suspense fallback={null}>
          <ambientLight intensity={0.5} />
          <pointLight position={[10, 10, 10]} />

          <VisualizationRenderer audioData={audioData} />

          <OrbitControls
            enableDamping
            dampingFactor={0.05}
            enableZoom={true}
            enablePan={false}
            maxPolarAngle={Math.PI / 2.2}
            minPolarAngle={Math.PI / 6}
            autoRotate={false}
          />
          <Stats />
        </Suspense>
      </Canvas>

      <div style={{
        position: 'absolute',
        top: '20px',
        left: '20px',
        zIndex: 1000,
        color: 'white',
        background: 'rgba(0,0,0,0.9)',
        padding: '15px',
        borderRadius: '8px',
        fontFamily: 'Arial, sans-serif',
        maxWidth: '350px',
        maxHeight: '90vh',
        overflowY: 'auto'
      }}>
        <h2 style={{ margin: '0 0 10px 0' }}>AuraSync - Enhanced Audio Analysis</h2>
        <input
          type="file"
          accept="audio/*"
          onChange={handleFileUpload}
          style={{ marginBottom: '10px' }}
        />
        <br />
        <audio
          ref={audioRef}
          controls
          style={{ width: '200px' }}
        />

        {/* Basic Audio Metrics */}
        <div style={{ marginTop: '15px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#88ff88' }}>üìä Basic Metrics</h3>
          <div>Volume: {Math.round(audioData.volume * 100)}%</div>
          <div>Smoothed: {Math.round(audioData.smoothedVolume * 100)}%</div>
          <div>Energy: {Math.round(audioData.energy * 100)}%</div>
          <div style={{ color: audioData.beat ? '#00ff00' : '#666' }}>
            Beat: {audioData.beat ? '‚óè' : '‚óã'}
          </div>
          <div>Drop Intensity: {Math.round(audioData.dropIntensity * 100)}%</div>
        </div>

        {/* Frequency Bands */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#ff8888' }}>üéöÔ∏è Frequency Bands</h3>
          <div>Bass: {Math.round(audioData.bands.bass * 100)}% | Dynamic: {Math.round(audioData.dynamicBands.bass * 100)}%</div>
          <div>Mid: {Math.round(audioData.bands.mid * 100)}% | Dynamic: {Math.round(audioData.dynamicBands.mid * 100)}%</div>
          <div>Treble: {Math.round(audioData.bands.treble * 100)}% | Dynamic: {Math.round(audioData.dynamicBands.treble * 100)}%</div>
        </div>

        {/* Transients */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#ffaa00' }}>‚ö° Transients</h3>
          <div style={{ display: 'flex', gap: '10px' }}>
            <span style={{ color: audioData.transients.bass ? '#ff0000' : '#666' }}>
              Bass: {audioData.transients.bass ? '‚óè' : '‚óã'}
            </span>
            <span style={{ color: audioData.transients.mid ? '#00ff00' : '#666' }}>
              Mid: {audioData.transients.mid ? '‚óè' : '‚óã'}
            </span>
            <span style={{ color: audioData.transients.treble ? '#0088ff' : '#666' }}>
              Treble: {audioData.transients.treble ? '‚óè' : '‚óã'}
            </span>
            <span style={{ color: audioData.transients.overall ? '#ff00ff' : '#666' }}>
              Overall: {audioData.transients.overall ? '‚óè' : '‚óã'}
            </span>
          </div>
        </div>

        {/* Rhythmic Features */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#8888ff' }}>ü•Å Rhythm Analysis</h3>
          <div>BPM: <strong>{audioData.rhythmicFeatures.bpm.toFixed(1)}</strong>
            <span style={{ color: audioData.rhythmicFeatures.bpmConfidence > 0.5 ? '#00ff00' : '#ff8800' }}>
              ({Math.round(audioData.rhythmicFeatures.bpmConfidence)}% confidence)
            </span>
          </div>
          <div>Beat Phase: {audioData.rhythmicFeatures.beatPhase.toFixed(3)}</div>
          <div>Subdivision: {audioData.rhythmicFeatures.subdivision}</div>
          <div>Groove: {Math.round(audioData.rhythmicFeatures.groove)}%</div>
        </div>

        {/* Enhanced Melodic Features - YIN Algorithm */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#ff88ff' }}>üéº YIN Pitch Detection</h3>
          <div>Detected Note: <strong style={{
            color: audioData.melodicFeatures.noteConfidence > 0.5 ? '#00ff00' : '#ffaa00'
          }}>{audioData.melodicFeatures.dominantNote}</strong></div>
          <div>Frequency: {audioData.melodicFeatures.dominantFrequency.toFixed(1)} Hz</div>
          <div>YIN Confidence: <span style={{
            color: audioData.melodicFeatures.noteConfidence > 0.7 ? '#00ff00' :
                  audioData.melodicFeatures.noteConfidence > 0.4 ? '#ffaa00' : '#ff4444'
          }}>{Math.round(audioData.melodicFeatures.noteConfidence * 100)}%</span></div>
          <div>Harmonic Richness: {Math.round(audioData.melodicFeatures.harmonicContent * 100)}%</div>

          {/* Enhanced Chromagram Visualization */}
          <div style={{ marginTop: '5px' }}>
            <div style={{ fontSize: '11px', fontWeight: 'bold' }}>Robust Chromagram:</div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '2px', fontSize: '9px' }}>
              {audioData.melodicFeatures.pitchClass.map((v, i) => {
                const noteName = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][i];
                const intensity = Math.round(v * 100);
                const isStrong = v > 0.15;
                return (
                  <div key={i} style={{
                    color: isStrong ? '#ffff00' : '#888',
                    fontWeight: isStrong ? 'bold' : 'normal'
                  }}>
                    {noteName}:{intensity}
                  </div>
                );
              })}
            </div>
          </div>
        </div>

        {/* NEW: Timbre Profile */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#ffaa88' }}>üé® Timbre Analysis</h3>
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px' }}>
            <div>Brightness: {Math.round(audioData.timbreProfile.brightness * 100)}%</div>
            <div>Warmth: {Math.round(audioData.timbreProfile.warmth * 100)}%</div>
            <div>Richness: {Math.round(audioData.timbreProfile.richness * 100)}%</div>
            <div>Clarity: {Math.round(audioData.timbreProfile.clarity * 100)}%</div>
            <div>Attack: {Math.round(audioData.timbreProfile.attack * 100)}%</div>
            <div>Complexity: {Math.round(audioData.timbreProfile.harmonicComplexity * 100)}%</div>
          </div>
          <div style={{ marginTop: '5px' }}>
            Dominant Chroma: {['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][audioData.timbreProfile.dominantChroma] || 'N/A'}
          </div>
        </div>

        {/* NEW: Musical Context */}
        <div style={{ marginTop: '10px', fontSize: '12px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#aaffaa' }}>üéµ Musical Context</h3>
          <div>Key: <strong>{audioData.musicalContext.key}</strong></div>
          <div>Mode: <span style={{
            color: audioData.musicalContext.mode === 'major' ? '#88ff88' :
                  audioData.musicalContext.mode === 'minor' ? '#ff8888' : '#888'
          }}>{audioData.musicalContext.mode}</span></div>
          <div>Note Present: <span style={{ color: audioData.musicalContext.notePresent ? '#00ff00' : '#666' }}>
            {audioData.musicalContext.notePresent ? '‚óè' : '‚óã'}
          </span></div>
          <div>Note Stability: {Math.round(audioData.musicalContext.noteStability * 100)}%</div>
          <div>Harmonic Tension: <span style={{
            color: audioData.musicalContext.tension > 0.7 ? '#ff4444' :
                  audioData.musicalContext.tension > 0.4 ? '#ffaa44' : '#44ff44'
          }}>{Math.round(audioData.musicalContext.tension * 100)}%</span></div>
        </div>

        {/* Spectral Features */}
        <div style={{ marginTop: '10px', fontSize: '12px' }}>
          <h3 style={{ margin: '0 0 5px 0', color: '#88ffff' }}>üåà Spectral Features</h3>
          <div>Centroid (Brightness): {Math.round(audioData.spectralFeatures.centroid * 100)}%</div>
          <div>Spread (Width): {Math.round(audioData.spectralFeatures.spread * 100)}%</div>
          <div>Flux (Change): {Math.round(audioData.spectralFeatures.flux * 100)}%</div>
          <div>Rolloff (Focus): {Math.round(audioData.spectralFeatures.rolloff * 100)}%</div>
          <div style={{ fontSize: '10px', color: '#888', marginTop: '5px' }}>
            FFT Bins: {audioData.frequencies.length} | Sample Rate: ~{audioData.frequencies.length * 2 * 22.05} Hz
          </div>
        </div>
      </div>

      <ConfigPanel />
    </div>
  )
}

export default App


--- main.tsx ---
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--- vite-env.d.ts ---
/// <reference types="vite/client" />


--- assets\react.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

--- components\ConfigPanel.tsx ---
import React from 'react';
import { useConfigStore } from '../store/configStore';
import { scenes, scenesById } from '../scenes';
import type { SceneSettingControl } from '../scenes/sceneTypes';

export function ConfigPanel() {
  const {
    visualization,
    setVisualization,
    updateVisualizationSettings,
    showConfigPanel,
    toggleConfigPanel,
    activeConfigTab,
    setActiveConfigTab,
  } = useConfigStore();

  if (!showConfigPanel) {
    return (
      <button
        onClick={toggleConfigPanel}
        style={{
          position: 'absolute',
          top: '20px',
          right: '20px',
          zIndex: 1001,
          padding: '10px 15px',
          background: 'rgba(0,0,0,0.8)',
          color: 'white',
          border: '1px solid #333',
          borderRadius: '6px',
          cursor: 'pointer',
          fontSize: '14px',
        }}
      >
        ‚öôÔ∏è Config
      </button>
    );
  }

  const panelStyle: React.CSSProperties = {
    position: 'absolute',
    top: '20px',
    right: '20px',
    zIndex: 1001,
    background: 'rgba(0,0,0,0.95)',
    color: 'white',
    padding: '20px',
    borderRadius: '8px',
    border: '1px solid #333',
    width: '320px',
    maxHeight: '80vh',
    overflowY: 'auto',
    fontSize: '13px',
  };

  const inputStyle: React.CSSProperties = {
    width: '100%',
    padding: '6px',
    marginTop: '4px',
    background: 'rgba(255,255,255,0.1)',
    border: '1px solid #555',
    borderRadius: '4px',
    color: 'white',
    fontSize: '12px',
  };

  const selectStyle: React.CSSProperties = {
    ...inputStyle,
    cursor: 'pointer',
  };

  const currentScene = scenesById[visualization.id];

  const renderControl = (key: string, control: SceneSettingControl) => {
    const value = visualization.settings[key];

    switch (control.type) {
      case 'slider':
        return (
          <div key={key} style={{ marginBottom: '15px' }}>
            <label style={{ display: 'block', marginBottom: '4px' }}>{control.label}:</label>
            <input
              type="range"
              min={control.min}
              max={control.max}
              step={control.step}
              value={value}
              onChange={(e) => updateVisualizationSettings({ [key]: parseFloat(e.target.value) })}
              style={inputStyle}
            />
            <span style={{ fontSize: '11px', color: '#aaa' }}>{value.toFixed(2)}</span>
          </div>
        );
      case 'color':
        return (
          <div key={key} style={{ marginBottom: '15px' }}>
            <label style={{ display: 'block', marginBottom: '4px' }}>{control.label}:</label>
            <input
              type="color"
              value={value}
              onChange={(e) => updateVisualizationSettings({ [key]: e.target.value })}
              style={inputStyle}
            />
          </div>
        );
      case 'select':
        return (
          <div key={key} style={{ marginBottom: '15px' }}>
            <label style={{ display: 'block', marginBottom: '4px' }}>{control.label}:</label>
            <select
              value={String(value)} // Ensure value is a string for the select
              onChange={(e) => {
                // Check if the value should be a boolean
                let newValue: any = e.target.value;
                if (e.target.value === 'true') {
                  newValue = true;
                } else if (e.target.value === 'false') {
                  newValue = false;
                }
                updateVisualizationSettings({ [key]: newValue });
              }}
              style={selectStyle}
            >
              {control.options?.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <div style={panelStyle}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
        <h3 style={{ margin: 0, fontSize: '16px' }}>AuraSync Config</h3>
        <button
          onClick={toggleConfigPanel}
          style={{ background: 'none', border: 'none', color: 'white', cursor: 'pointer', fontSize: '18px' }}
        >
          √ó
        </button>
      </div>

      <div style={{ display: 'flex', marginBottom: '20px', borderBottom: '1px solid #333' }}>
        {['global', 'visualization'].map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveConfigTab(tab as any)}
            style={{
              flex: 1,
              padding: '8px',
              background: activeConfigTab === tab ? '#0066cc' : 'transparent',
              border: 'none',
              color: 'white',
              cursor: 'pointer',
              textTransform: 'capitalize',
              fontSize: '12px',
            }}
          >
            {tab}
          </button>
        ))}
      </div>

      {activeConfigTab === 'global' && (
        <div>
          {/* Global settings controls here */}
        </div>
      )}

      {activeConfigTab === 'visualization' && (
        <div>
          <div style={{ marginBottom: '20px' }}>
            <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>Visualization Mode:</label>
            <select
              value={visualization.id}
              onChange={(e) => setVisualization(e.target.value)}
              style={selectStyle}
            >
              {scenes.map((scene) => (
                <option key={scene.id} value={scene.id}>
                  {scene.name}
                </option>
              ))}
            </select>
          </div>

          {currentScene && Object.entries(currentScene.settings.schema).map(([key, control]) => renderControl(key, control))}
        </div>
      )}
    </div>
  );
}

--- glsl\raymarching.glsl ---


--- glsl\sdf.glsl ---


--- glsl\tunnelSDF.glsl ---


--- hooks\useAudioAnalyzer.ts ---
import { useEffect, useRef, useState } from 'react';
import { BPMDetector } from '../utils/BPMDetector';
import { YINPitchDetector } from '../utils/YINPitchDetector';
import { TimbreAnalyzer, type TimbreProfile, type MusicalContext } from '../utils/timbreAnalyzer';
import { createMelFilterbank, calculateRobustODF, calculateMedian } from '../utils/melFilterbank';

// --- Type Definitions ---
export interface FrequencyBands {
  bass: number; // 20-250 Hz
  mid: number; // 250-4000 Hz
  treble: number; // 4000-20000 Hz
}

export interface Transients {
  bass: boolean;
  mid: boolean;
  treble: boolean;
  overall: boolean;
}

export interface SpectralFeatures {
  centroid: number; // Brightness indicator (0-1)
  spread: number; // Spectral width (0-1)
  flux: number; // Spectral change rate (0-1)
  rolloff: number; // Frequency below which 85% of energy is contained (0-1)
}

export interface MelodicFeatures {
  dominantFrequency: number; // Hz
  dominantNote: string; // Musical note (e.g., "A4", "C#5")
  noteConfidence: number; // 0-1
  harmonicContent: number; // 0-1, measure of harmonic richness
  pitchClass: number[]; // 12-element chroma vector
}

export interface RhythmicFeatures {
  bpm: number;
  bpmConfidence: number; // 0-100
  beatPhase: number; // 0-1, position within current beat
  subdivision: number; // 1, 2, 4, 8 etc - detected rhythmic subdivision
  groove: number; // 0-100, measure of rhythmic stability
}

export interface AudioData {
  frequencies: Uint8Array;
  waveform: Uint8Array;
  volume: number;
  bands: FrequencyBands;
  dynamicBands: FrequencyBands;
  transients: Transients;
  energy: number;
  dropIntensity: number;
  spectralFeatures: SpectralFeatures;
  melodicFeatures: MelodicFeatures;
  rhythmicFeatures: RhythmicFeatures;
  timbreProfile: TimbreProfile;
  musicalContext: MusicalContext;
  bass: number;
  mids: number;
  treble: number;
  beat: boolean;
  smoothedVolume: number;
}

// --- Configuration ---
const ENVELOPE_CONFIG = {
  minDecay: 0.002,
  maxDecay: 0.001,
  minThreshold: 0.02,
  adaptiveRate: 0.1,
};

const DROP_CONFIG = {
  decay: 0.95,
  threshold: 0.5,
  cooldown: 500,
};

const TRANSIENT_CONFIG = {
  bass: { threshold: 0.08, multiplier: 1.8, decay: 0.85 },     // Reduced from 0.12
  mid: { threshold: 0.07, multiplier: 2.0, decay: 0.9 },      // Reduced from 0.10
  treble: { threshold: 0.06, multiplier: 2.2, decay: 0.92 },  // Reduced from 0.08
  overall: { threshold: 0.12, multiplier: 1.7, decay: 0.88 }, // Reduced from 0.15
};

// Musical note frequencies (A4 = 440Hz)
const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const A4_FREQ = 440;
const A4_MIDI = 69;

// Perceptual weighting curve (A-weighting approximation)
const A_WEIGHTING = (freq: number): number => {
  const f2 = freq * freq;
  const f4 = f2 * f2;
  return (12194 * 12194 * f4) /
      ((f2 + 20.6 * 20.6) * Math.sqrt((f2 + 107.7 * 107.7) * (f2 + 737.9 * 737.9)) * (f2 + 12194 * 12194));
};

// Convert frequency to musical note
const frequencyToNote = (freq: number): { note: string; cents: number } => {
  if (freq <= 0) return { note: 'N/A', cents: 0 };

  const midiNumber = 12 * Math.log2(freq / A4_FREQ) + A4_MIDI;
  const roundedMidi = Math.round(midiNumber);
  const cents = (midiNumber - roundedMidi) * 100;

  const octave = Math.floor(roundedMidi / 12) - 1;
  const noteIndex = roundedMidi % 12;

  return {
    note: `${NOTE_NAMES[noteIndex]}${octave}`,
    cents: Math.round(cents)
  };
};

export function useAudioAnalyzer(audioSource?: HTMLAudioElement) {
  const [audioData, setAudioData] = useState<AudioData>({
    frequencies: new Uint8Array(512),
    waveform: new Uint8Array(512),
    volume: 0,
    bands: { bass: 0, mid: 0, treble: 0 },
    dynamicBands: { bass: 0, mid: 0, treble: 0 },
    transients: { bass: false, mid: false, treble: false, overall: false },
    energy: 0,
    dropIntensity: 0,
    spectralFeatures: { centroid: 0, spread: 0, flux: 0, rolloff: 0 },
    melodicFeatures: {
      dominantFrequency: 0,
      dominantNote: 'N/A',
      noteConfidence: 0,
      harmonicContent: 0,
      pitchClass: new Array(12).fill(0)
    },
    rhythmicFeatures: {
      bpm: 0,
      bpmConfidence: 0,
      beatPhase: 0,
      subdivision: 1,
      groove: 0
    },
    // NEW: Initialiser des valeurs par d√©faut pour le profil timbral et le contexte musical
    timbreProfile: {
      brightness: 0,
      warmth: 0,
      richness: 0,
      clarity: 0,
      attack: 0,
      dominantChroma: 0,
      harmonicComplexity: 0
    },
    musicalContext: {
      notePresent: false,
      noteStability: 0,
      key: 'C',
      mode: 'unknown',
      tension: 0
    },
    bass: 0,
    mids: 0,
    treble: 0,
    beat: false,
    smoothedVolume: 0,
  });

  const analyserRef = useRef<AnalyserNode | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const animationRef = useRef<number>(0);
  const sourceNodeRef = useRef<MediaElementAudioSourceNode | null>(null);

  // --- Analysis state refs ---
  const prevBandsRef = useRef<FrequencyBands>({ bass: 0, mid: 0, treble: 0 });
  const prevFrequenciesRef = useRef<Float32Array>(new Float32Array(512));
  const transientStateRef = useRef({
    bass: { value: 0, history: new Array(10).fill(0) },
    mid: { value: 0, history: new Array(10).fill(0) },
    treble: { value: 0, history: new Array(10).fill(0) },
    overall: { value: 0, history: new Array(10).fill(0) },
  });
  const bandEnvelopeRef = useRef({
    bass: { min: 0.1, max: 0.2 },
    mid: { min: 0.1, max: 0.2 },
    treble: { min: 0.1, max: 0.2 },
  });
  const energyEnvelopeRef = useRef({ min: 0.1, max: 0.2 });
  const prevNormalizedEnergyRef = useRef(0);
  const dropIntensityRef = useRef(0);
  const lastDropTimeRef = useRef(0);

  // NEW: YIN Pitch Detector for superior fundamental frequency detection
  const yinDetectorRef = useRef<YINPitchDetector | null>(null);

  // NEW: Timbre Analyzer for advanced musical analysis
  const timbreAnalyzerRef = useRef<TimbreAnalyzer | null>(null);

  // NOUVEAU: Refs pour le BPM Detector bas√© sur l'autocorr√©lation
  const bpmDetectorRef = useRef(new BPMDetector());
  const odfHistoryRef = useRef<number[]>([]); // Historique de l'ODF pour l'ACF
  const lastBeatTimeRef = useRef(0);
  const ODF_SAMPLE_RATE = 43; // R√©duit de 45 √† 43 Hz pour exactement 256 samples = 5.95 secondes
  const ODF_HISTORY_SIZE = 256; // Environ 5.6 secondes d'historique

  // FIXED: Store real sample rate from AudioContext
  const realSampleRateRef = useRef<number>(44100); // Default fallback

  // NEW: Chromagram smoothing
  const chromaSmoothingRef = useRef<number[]>(new Array(12).fill(0));
  const CHROMA_SMOOTHING = 0.85; // Smoothing factor

  // NEW: Mel filterbank for robust ODF
  const melFilterbankRef = useRef<number[][] | null>(null);
  const prevMelEnergiesRef = useRef<Float32Array | null>(null);
  const MEL_BANDS = 40; // Number of Mel bands for ODF calculation

  // --- Enhanced Analysis Functions ---

  const calculateBands = (frequencies: Uint8Array, sampleRate: number): FrequencyBands => {
    const nyquist = sampleRate / 2;
    const binSize = nyquist / frequencies.length;

    const bassEnd = Math.floor(250 / binSize);
    const midEnd = Math.floor(4000 / binSize);

    let bass = 0, mid = 0, treble = 0;
    let bassWeight = 0, midWeight = 0, trebleWeight = 0;

    for (let i = 1; i < frequencies.length; i++) {
      const freq = i * binSize;
      const magnitude = frequencies[i] / 255;

      const weight = A_WEIGHTING(freq);
      const weightedMagnitude = magnitude * weight;

      if (i <= bassEnd) {
        bass += weightedMagnitude;
        bassWeight += weight;
      } else if (i <= midEnd) {
        mid += weightedMagnitude;
        midWeight += weight;
      } else if (freq < nyquist - binSize) {
        treble += weightedMagnitude;
        trebleWeight += weight;
      }
    }

    return {
      bass: bassWeight > 0 ? bass / bassWeight : 0,
      mid: midWeight > 0 ? mid / midWeight : 0,
      treble: trebleWeight > 0 ? treble / trebleWeight : 0,
    };
  };

  const calculateSpectralFeatures = (frequencies: Uint8Array, sampleRate: number): SpectralFeatures => {
    const nyquist = sampleRate / 2;
    const binSize = nyquist / frequencies.length;

    let totalEnergy = 0;
    let centroidSum = 0;

    // NEW: Initialize Mel filterbank if not already done
    if (!melFilterbankRef.current) {
      melFilterbankRef.current = createMelFilterbank(frequencies.length * 2, MEL_BANDS, sampleRate);
      prevMelEnergiesRef.current = new Float32Array(MEL_BANDS).fill(0);
      console.log('üéµ Mel Filterbank initialized with', MEL_BANDS, 'bands for robust ODF');
    }

    // Calculate spectral centroid, spread, and rolloff
    for (let i = 1; i < frequencies.length - 1; i++) {
      const magnitude = frequencies[i] / 255;
      const freq = i * binSize;

      totalEnergy += magnitude;
      centroidSum += magnitude * freq;
    }

    const centroid = totalEnergy > 0 ? (centroidSum / totalEnergy) / nyquist : 0;

    let cumulativeEnergy = 0;
    let rolloff = 0;
    for (let i = 1; i < frequencies.length - 1; i++) {
      cumulativeEnergy += frequencies[i] / 255;
      if (cumulativeEnergy >= totalEnergy * 0.85) {
        rolloff = (i * binSize) / nyquist;
        break;
      }
    }

    let spreadSum = 0;
    if (totalEnergy > 0) {
      const centroidHz = centroid * nyquist;
      for (let i = 1; i < frequencies.length - 1; i++) {
        const magnitude = frequencies[i] / 255;
        const freq = i * binSize;
        spreadSum += magnitude * Math.pow(freq - centroidHz, 2);
      }
    }
    const spread = totalEnergy > 0 ? Math.sqrt(spreadSum / totalEnergy) / nyquist : 0;

    // NEW: Calculate robust multi-band ODF instead of simple spectral flux
    let flux = 0;
    if (melFilterbankRef.current && prevMelEnergiesRef.current) {
      flux = calculateRobustODF(
        frequencies,
        prevMelEnergiesRef.current,
        melFilterbankRef.current,
        MEL_BANDS
      );
    } else {
      // Fallback to old method if filterbank not ready
      const spectralChanges: number[] = [];
      for (let i = 1; i < frequencies.length - 1; i++) {
        const magnitude = frequencies[i] / 255;
        const prevMag = prevFrequenciesRef.current[i];
        const change = magnitude - prevMag;
        if (change > 0) {
          spectralChanges.push(change);
        }
      }
      flux = calculateMedian(spectralChanges);
    }

    // Update frequency history for potential fallback
    for (let i = 0; i < frequencies.length; i++) {
      prevFrequenciesRef.current[i] = frequencies[i] / 255;
    }

    return {
      centroid: Math.min(1, centroid),
      spread: Math.min(1, spread),
      flux: Math.min(1, flux * 10), // Scale for better dynamic range
      rolloff: Math.min(1, rolloff),
    };
  };

  // YIN-based melodic analysis with robust chromagram
  const calculateMelodicFeatures = (
    waveform: Uint8Array,
    frequencies: Uint8Array,
    sampleRate: number
  ): MelodicFeatures => {
    // Initialize YIN detector with improved settings
    if (!yinDetectorRef.current) {
      yinDetectorRef.current = new YINPitchDetector(sampleRate, 4096, 0.15); // Larger buffer, higher threshold
    }

    // Convert waveform for YIN algorithm with better normalization
    const float32Waveform = new Float32Array(waveform.length);
    let maxValue = 0;

    // First pass: find max value for proper normalization
    for (let i = 0; i < waveform.length; i++) {
      const sample = Math.abs((waveform[i] - 128) / 128);
      if (sample > maxValue) maxValue = sample;
    }

    // Second pass: normalize properly
    const normalizationFactor = maxValue > 0 ? 1 / maxValue : 1;
    for (let i = 0; i < waveform.length; i++) {
      float32Waveform[i] = ((waveform[i] - 128) / 128) * normalizationFactor;
    }

    // YIN pitch detection
    const pitchResult = yinDetectorRef.current.detectPitch(float32Waveform);
    let dominantFreq = pitchResult.frequency;
    let noteConfidence = pitchResult.probability;

    // FALLBACK: If YIN fails, use spectral peak detection
    if (dominantFreq <= 0 || noteConfidence < 0.3) {
      const nyquist = sampleRate / 2;
      const binSize = nyquist / frequencies.length;

      let maxMagnitude = 0;
      let maxBin = 0;

      // Focus on melodic range (80Hz - 1000Hz)
      const minBin = Math.floor(80 / binSize);
      const maxBinLimit = Math.floor(1000 / binSize);

      for (let i = minBin; i < Math.min(maxBinLimit, frequencies.length); i++) {
        if (frequencies[i] > maxMagnitude) {
          maxMagnitude = frequencies[i];
          maxBin = i;
        }
      }

      if (maxMagnitude > 30) { // Minimum threshold for detection
        // Parabolic interpolation for better accuracy
        if (maxBin > 0 && maxBin < frequencies.length - 1) {
          const y1 = frequencies[maxBin - 1];
          const y2 = frequencies[maxBin];
          const y3 = frequencies[maxBin + 1];

          const x0 = (y3 - y1) / (2 * (2 * y2 - y1 - y3));
          dominantFreq = (maxBin + x0) * binSize;
        } else {
          dominantFreq = maxBin * binSize;
        }

        noteConfidence = Math.min(0.8, maxMagnitude / 255); // Cap confidence from spectral method
      }
    }

    const { note } = frequencyToNote(dominantFreq);

    // Robust chromagram calculation with temporal smoothing
    const chroma = new Array(12).fill(0);
    const nyquist = sampleRate / 2;
    const binSize = nyquist / frequencies.length;

    // Map spectrum to pitch classes with proper weighting
    for (let i = 1; i < frequencies.length; i++) {
      const freq = i * binSize;
      const magnitude = frequencies[i] / 255;

      if (freq < 80 || freq > 4000) continue;

      // Find closest MIDI note
      const midiNote = 12 * Math.log2(freq / 440) + 69;
      const pitchClass = ((Math.round(midiNote) % 12) + 12) % 12;

      // Weight by magnitude and perceptual importance
      const weight = magnitude * A_WEIGHTING(freq);

      // Distribute energy to neighboring pitch classes for robustness
      chroma[pitchClass] += weight * 0.7;
      chroma[(pitchClass + 11) % 12] += weight * 0.15;
      chroma[(pitchClass + 1) % 12] += weight * 0.15;
    }

    // Normalize
    const chromaSum = chroma.reduce((a, b) => a + b, 0);
    if (chromaSum > 0) {
      for (let i = 0; i < 12; i++) {
        chroma[i] /= chromaSum;
      }
    }

    // Apply temporal smoothing
    for (let i = 0; i < 12; i++) {
      chromaSmoothingRef.current[i] = chromaSmoothingRef.current[i] * CHROMA_SMOOTHING +
                                       chroma[i] * (1 - CHROMA_SMOOTHING);
      chroma[i] = chromaSmoothingRef.current[i];
    }

    // Calculate harmonic content - FIXED
    let harmonicContent = 0;
    if (dominantFreq > 0 && frequencies.length > 0) {
      const fundamentalBin = Math.floor(dominantFreq / binSize);
      let fundamentalEnergy = 0;
      let harmonicEnergy = 0;

      // Get fundamental energy (average over 3 bins for robustness)
      for (let i = -1; i <= 1; i++) {
        const bin = fundamentalBin + i;
        if (bin >= 0 && bin < frequencies.length) {
          fundamentalEnergy += frequencies[bin] / 255;
        }
      }
      fundamentalEnergy /= 3;

      // Sum harmonic energies
      for (let harmonic = 2; harmonic <= 6; harmonic++) {
        const harmonicBin = Math.floor((dominantFreq * harmonic) / binSize);
        if (harmonicBin < frequencies.length) {
          // Average over neighboring bins
          let energy = 0;
          for (let i = -1; i <= 1; i++) {
            const bin = harmonicBin + i;
            if (bin >= 0 && bin < frequencies.length) {
              energy += frequencies[bin] / 255;
            }
          }
          harmonicEnergy += energy / 3;
        }
      }

      // Calculate ratio (0-1 range)
      if (fundamentalEnergy > 0.01) {
        harmonicContent = Math.min(1, harmonicEnergy / (fundamentalEnergy * 5));
      }
    }

    return {
      dominantFrequency: dominantFreq,
      dominantNote: note,
      noteConfidence,
      harmonicContent,
      pitchClass: chromaSmoothingRef.current
    };
  };

  // Autocorrelation-based rhythmic analysis
  const calculateRhythmicFeatures = (spectralFlux: number, currentTime: number, isOverallTransient: boolean): RhythmicFeatures => {
    // Update ODF history
    odfHistoryRef.current.push(spectralFlux);
    if (odfHistoryRef.current.length > ODF_HISTORY_SIZE) {
      odfHistoryRef.current.shift();
    }

    // BPM detection via autocorrelation
    const bpm = bpmDetectorRef.current.detectBPM(odfHistoryRef.current, ODF_SAMPLE_RATE);
    const confidence = bpmDetectorRef.current.getConfidence();

    // Debug logging for BPM detection
    if (bpm > 0 && confidence > 0.5) {
      console.log(`BPM: ${bpm.toFixed(1)}, Conf: ${(confidence * 100).toFixed(0)}%`);
    }

    // Update beat timing on strong transients
    if (isOverallTransient) {
      lastBeatTimeRef.current = currentTime;
    }

    const beatPhase = bpmDetectorRef.current.getBeatPhase(currentTime, bpm, lastBeatTimeRef.current);

    // Detect rhythmic subdivision
    let subdivision = 1;
    if (audioData.transients) {
      const transientCount = [
        audioData.transients.bass,
        audioData.transients.mid,
        audioData.transients.treble
      ].filter(Boolean).length;

      if (transientCount >= 2) subdivision = 2;
      if (transientCount === 3) subdivision = 4;
    }

    return {
      bpm: Math.round(bpm * 10) / 10,
      bpmConfidence: confidence * 100,
      beatPhase: Math.round(beatPhase * 1000) / 1000,
      subdivision,
      groove: confidence * 100
    };
  };

  const calculateDynamicValue = (value: number, envelope: { min: number; max: number }): number => {
    if (value > envelope.max) {
      envelope.max = value * (1 - ENVELOPE_CONFIG.adaptiveRate) + envelope.max * ENVELOPE_CONFIG.adaptiveRate;
    } else {
      envelope.max *= (1 - ENVELOPE_CONFIG.maxDecay);
    }

    if (value < envelope.min) {
      envelope.min = value * (1 - ENVELOPE_CONFIG.adaptiveRate) + envelope.min * ENVELOPE_CONFIG.adaptiveRate;
    } else {
      envelope.min = envelope.min * (1 + ENVELOPE_CONFIG.minDecay) + ENVELOPE_CONFIG.minThreshold;
    }

    envelope.min = Math.max(0, Math.min(envelope.min, 0.9));
    envelope.max = Math.max(envelope.min + 0.1, Math.min(envelope.max, 1));

    const range = envelope.max - envelope.min;
    return range > 0.01 ? Math.max(0, Math.min(1, (value - envelope.min) / range)) : value;
  };

  const detectTransients = (currentBands: FrequencyBands, energy: number): Transients => {
    const transients: Transients = { bass: false, mid: false, treble: false, overall: false };

    const detectBandTransient = (
        current: number,
        band: 'bass' | 'mid' | 'treble' | 'overall',
        value: number = current
    ): boolean => {
      const config = TRANSIENT_CONFIG[band];
      const state = transientStateRef.current[band];

      state.history.shift();
      state.history.push(value);

      const avgHistory = state.history.reduce((a, b) => a + b, 0) / state.history.length;
      const adaptiveThreshold = Math.max(config.threshold, avgHistory * config.multiplier);

      const isTransient = value > adaptiveThreshold && value > state.value * config.multiplier;

      state.value = state.value * config.decay + value * (1 - config.decay);

      return isTransient;
    };

    transients.bass = detectBandTransient(currentBands.bass, 'bass');
    transients.mid = detectBandTransient(currentBands.mid, 'mid');
    transients.treble = detectBandTransient(currentBands.treble, 'treble');
    transients.overall = detectBandTransient(energy, 'overall');

    return transients;
  };

  const detectDrop = (normalizedEnergy: number): number => {
    const now = Date.now();
    const surge = normalizedEnergy - prevNormalizedEnergyRef.current;

    if (surge > DROP_CONFIG.threshold && now - lastDropTimeRef.current > DROP_CONFIG.cooldown) {
      dropIntensityRef.current = Math.min(1, surge);
      lastDropTimeRef.current = now;
    }

    prevNormalizedEnergyRef.current = normalizedEnergy;
    dropIntensityRef.current *= DROP_CONFIG.decay;

    return dropIntensityRef.current;
  };

  useEffect(() => {
    if (!audioSource) return;

    try {
      audioContextRef.current = new AudioContext();
      analyserRef.current = audioContextRef.current.createAnalyser();

      // FIXED: Capture the real sample rate from AudioContext
      realSampleRateRef.current = audioContextRef.current.sampleRate;
      console.log('üéõÔ∏è AudioContext Sample Rate:', realSampleRateRef.current, 'Hz');

    } catch (error) {
      console.error('Failed to initialize AudioContext:', error);
      return;
    }

    analyserRef.current.fftSize = 2048; // Consider 4096 for melody detection
    analyserRef.current.smoothingTimeConstant = 0.75;
    analyserRef.current.minDecibels = -90;
    analyserRef.current.maxDecibels = -10;

    const bufferLength = analyserRef.current.frequencyBinCount;

    try {
      sourceNodeRef.current = audioContextRef.current.createMediaElementSource(audioSource);
      sourceNodeRef.current.connect(analyserRef.current);
      analyserRef.current.connect(audioContextRef.current.destination);
    } catch (error) {
      console.error('Failed to connect audio source:', error);
      return;
    }

    const frequencies = new Uint8Array(bufferLength);
    const waveform = new Uint8Array(bufferLength);
    prevFrequenciesRef.current = new Float32Array(bufferLength);

    const analyze = () => {
      if (!analyserRef.current || !audioContextRef.current) return;

      analyserRef.current.getByteFrequencyData(frequencies);
      analyserRef.current.getByteTimeDomainData(waveform);

      const maxFreq = Math.max(...Array.from(frequencies));
      if (maxFreq < 5) {
        setAudioData(prev => ({
          ...prev,
          volume: 0,
          energy: 0,
          bands: { bass: 0, mid: 0, treble: 0 },
          dynamicBands: { bass: 0, mid: 0, treble: 0 },
          transients: { bass: false, mid: false, treble: false, overall: false },
          dropIntensity: prev.dropIntensity * DROP_CONFIG.decay,
          melodicFeatures: {
            dominantFrequency: 0,
            dominantNote: 'N/A',
            noteConfidence: 0,
            harmonicContent: 0,
            pitchClass: new Array(12).fill(0)
          },
          rhythmicFeatures: {
            ...prev.rhythmicFeatures,
            bpm: 0,
            bpmConfidence: 0,
            beatPhase: 0,
            groove: prev.rhythmicFeatures.groove * 0.95
          }
        }));
        animationRef.current = requestAnimationFrame(analyze);
        return;
      }

      let rms = 0;
      for (let i = 0; i < waveform.length; i++) {
        const sample = (waveform[i] - 128) / 128;
        rms += sample * sample;
      }
      const volume = Math.sqrt(rms / waveform.length);

      let energy = 0;
      for (let i = 1; i < frequencies.length - 1; i++) {
        const magnitude = frequencies[i] / 255;
        energy += magnitude * magnitude;
      }
      energy = Math.sqrt(energy / (frequencies.length - 2));

      // FIXED: Use real sample rate everywhere
      const sampleRate = realSampleRateRef.current;
      const bands = calculateBands(frequencies, sampleRate);
      const spectralFeatures = calculateSpectralFeatures(frequencies, sampleRate);
      const melodicFeatures = calculateMelodicFeatures(waveform, frequencies, sampleRate);

      const dynamicBands = {
        bass: calculateDynamicValue(bands.bass, bandEnvelopeRef.current.bass),
        mid: calculateDynamicValue(bands.mid, bandEnvelopeRef.current.mid),
        treble: calculateDynamicValue(bands.treble, bandEnvelopeRef.current.treble),
      };

      const normalizedEnergy = calculateDynamicValue(energy, energyEnvelopeRef.current);
      const dropIntensity = detectDrop(normalizedEnergy);
      const transients = detectTransients(bands, energy);

      // Update YIN detector with real sample rate if needed
      if (yinDetectorRef.current && yinDetectorRef.current.updateSampleRate) {
        yinDetectorRef.current.updateSampleRate(sampleRate);
      }

      // MODIFICATION: Appel √† la nouvelle fonction rythmique avec le transient actuel
      const currentTime = performance.now() / 1000;
      // On passe le flux spectral ET le transient du frame actuel pour une synchronisation parfaite
      const rhythmicFeatures = calculateRhythmicFeatures(spectralFeatures.flux, currentTime, transients.overall);

      // NEW: Use TimbreAnalyzer for advanced musical analysis
      if (!timbreAnalyzerRef.current) {
        timbreAnalyzerRef.current = new TimbreAnalyzer();
      }

      const timbreProfile = timbreAnalyzerRef.current.analyzeTimbre(melodicFeatures, spectralFeatures);
      const musicalContext = timbreAnalyzerRef.current.analyzeMusicalContext(melodicFeatures, timbreProfile);

      setAudioData(prev => ({
        ...prev,
        frequencies: frequencies.slice(),
        waveform: waveform.slice(),
        volume,
        energy,
        bands,
        dynamicBands,
        transients,
        dropIntensity,
        spectralFeatures,
        melodicFeatures,
        rhythmicFeatures,
        timbreProfile,
        musicalContext,
        bass: dynamicBands.bass,
        mids: dynamicBands.mid,
        treble: dynamicBands.treble,
        beat: transients.overall,
        smoothedVolume: volume,
      }));

      prevBandsRef.current = bands;
      animationRef.current = requestAnimationFrame(analyze);
    };

    analyze();

    return () => {
      if (animationRef.current) cancelAnimationFrame(animationRef.current);
      if (sourceNodeRef.current) sourceNodeRef.current.disconnect();
      if (analyserRef.current) analyserRef.current.disconnect();
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        audioContextRef.current.close();
      }
    };
  }, [audioSource]);

  return audioData;
}

--- scenes\Bars2D.tsx ---

import { useFrame } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { SceneDefinition } from './sceneTypes';

// 1. Define the settings interface
interface Bars2DSettings {
  barCount: number;
  maxHeight: number;
  colorMode: 'frequency' | 'rainbow' | 'single';
  smoothing: number;
  barWidth: number;
  spacing: number;
  baseColor: string;
}

// 2. Create the scene component
const Bars2DComponent: React.FC<{ audioData: AudioData; config: Bars2DSettings; globalConfig: any }> = ({ audioData, config, globalConfig }) => {
    const groupRef = useRef<THREE.Group>(null)
    const barRefs = useRef<(THREE.Mesh | null)[]>([])
    const targetHeights = useRef<number[]>([])
    const currentHeights = useRef<number[]>([])
    
    // Initialize arrays
    if (targetHeights.current.length !== config.barCount) {
      targetHeights.current = new Array(config.barCount).fill(0.1)
      currentHeights.current = new Array(config.barCount).fill(0.1)
    }
    
    useFrame(() => {
      if (!groupRef.current) return
      
      // Update each bar based on frequency data
      barRefs.current.forEach((bar, index) => {
        if (!bar || index >= config.barCount) return
        
        // Map bar index to frequency range
        const frequencyIndex = Math.floor((index / config.barCount) * audioData.frequencies.length)
        const frequency = audioData.frequencies[frequencyIndex] || 0
        
        // Calculate target height with volume multiplier
        const normalizedFreq = (frequency / 255) * globalConfig.volumeMultiplier
        targetHeights.current[index] = Math.max(0.1, normalizedFreq * config.maxHeight)
        
        // Smooth interpolation
        const lerpFactor = 1 - config.smoothing
        currentHeights.current[index] += (targetHeights.current[index] - currentHeights.current[index]) * lerpFactor
        
        // Update bar scale (Y = height, X/Z = width)
        bar.scale.set(config.barWidth, currentHeights.current[index], config.barWidth)
        
        // Position bar at half its height so it grows upward
        bar.position.y = currentHeights.current[index] / 2
        
        // Color based on mode
        const material = bar.material as THREE.MeshStandardMaterial
        
        switch (config.colorMode) {
          case "frequency":
            // Color based on frequency intensity
            const hue = (frequency / 255) * 0.8 // Blue to red spectrum
            const saturation = 0.8 + (frequency / 255) * 0.2
            const lightness = 0.3 + (frequency / 255) * 0.4
            material.color.setHSL(hue, saturation, lightness)
            break
            
          case "rainbow":
            // Rainbow spectrum across bars
            const rainbowHue = (index / config.barCount) * 1.0
            const intensity = frequency / 255
            material.color.setHSL(rainbowHue, 0.8, 0.3 + intensity * 0.4)
            break
            
          case "single":
            // Single base color with intensity variation
            const baseColor = new THREE.Color(config.baseColor)
            const intensityMultiplier = 0.3 + (frequency / 255) * 0.7
            material.color.copy(baseColor).multiplyScalar(intensityMultiplier)
            break
        }
        
        // Emissive effect for glow
        material.emissive.copy(material.color).multiplyScalar(0.2)
      })
    })
    
    // Generate bars
    const bars = []
    const totalWidth = config.barCount * config.spacing
    const startX = -totalWidth / 2
    
    for (let i = 0; i < config.barCount; i++) {
      bars.push(
        <mesh
          key={i}
          ref={(el) => (barRefs.current[i] = el)}
          position={[startX + i * config.spacing, 0, 0]}
        >
          <boxGeometry args={[config.barWidth, 1, config.barWidth]} />
          <meshStandardMaterial 
            color={config.baseColor}
            metalness={0.3}
            roughness={0.4}
          />
        </mesh>
      )
    }
    
    return <group ref={groupRef}>{bars}</group>
};

// 3. Define the scene configuration
export const bars2DScene: SceneDefinition<Bars2DSettings> = {
  id: 'bars2d',
  name: 'Bars 2D',
  component: Bars2DComponent,
  settings: {
    default: {
      barCount: 32,
      maxHeight: 8,
      colorMode: 'frequency',
      smoothing: 0.8,
      barWidth: 0.8,
      spacing: 1.2,
      baseColor: '#00ffff',
    },
    schema: {
      barCount: {
        type: 'slider',
        label: 'Bar Count',
        min: 8,
        max: 128,
        step: 8,
      },
      maxHeight: {
        type: 'slider',
        label: 'Max Height',
        min: 2,
        max: 20,
        step: 0.5,
      },
      smoothing: {
        type: 'slider',
        label: 'Smoothing',
        min: 0,
        max: 0.95,
        step: 0.05,
      },
      colorMode: {
        type: 'select',
        label: 'Color Mode',
        options: [
          { value: 'frequency', label: 'Frequency' },
          { value: 'rainbow', label: 'Rainbow' },
          { value: 'single', label: 'Single Color' },
        ],
      },
      baseColor: {
        type: 'color',
        label: 'Base Color',
      },
    },
  },
};


--- scenes\ConstellationVivante.tsx ---
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { SceneDefinition, SceneSettingsSchema } from './sceneTypes';
import { getAudioValue, applyReactivityCurve } from '../utils/audioUtils';
import type { GlobalSettings, AudioLink, ConstellationFormation, ConnectionType, ColorMode } from '../types/config';

// 1. Define the settings interface
interface ConstellationSettings {
  particleCount: number;
  formation: ConstellationFormation;
  connectionType: ConnectionType;
  connectionDistance: number;
  connectionOpacity: number;
  particleSize: number;
  particleAudioLink: AudioLink;
  formationSpeed: number;
  explosionIntensity: number;
  trailLength: number;
  colorMode: ColorMode;
  baseColor: string;
  formationScale: number;
  rotationSpeed: [number, number, number];
}

interface Particle {
  position: THREE.Vector3;
  targetPosition: THREE.Vector3;
  velocity: THREE.Vector3;
  basePosition: THREE.Vector3;
  id: number;
}

interface Connection {
  from: number;
  to: number;
  strength: number;
}

// 2. Create the scene component
const ConstellationVivanteComponent: React.FC<{ audioData: AudioData; config: ConstellationSettings; globalConfig: GlobalSettings }> = ({ audioData, config, globalConfig }) => {
  const groupRef = useRef<THREE.Group>(null);
  const particlesRef = useRef<(THREE.Mesh | null)[]>([]);
  const connectionLinesRef = useRef<THREE.BufferGeometry | null>(null);

  // Initialize particles with formation
  const particles = useMemo<Particle[]>(() => {
    const particleArray: Particle[] = [];

    for (let i = 0; i < config.particleCount; i++) {
      const basePos = generateFormationPosition(i, config.particleCount, config.formation, config.formationScale);

      particleArray.push({
        position: basePos.clone(),
        targetPosition: basePos.clone(),
        velocity: new THREE.Vector3(0, 0, 0),
        basePosition: basePos.clone(),
        id: i
      });
    }

    return particleArray;
  }, [config.particleCount, config.formation, config.formationScale]);

  // Calculate connections based on formation structure and mode
  const connections = useMemo<Connection[]>(() => {
    if (config.connectionType === 'formation-based') {
      return generateFormationConnections(config.particleCount, config.formation);
    } else if (config.connectionType === 'proximity') {
      // Sequential connections for organic flow
      const connectionArray: Connection[] = [];
      for (let i = 0; i < particles.length - 1; i++) {
        connectionArray.push({
          from: i,
          to: i + 1,
          strength: 1.0
        });

        // Add some cross-connections for structure
        if (i % 10 === 0 && i + 10 < particles.length) {
          connectionArray.push({
            from: i,
            to: i + 10,
            strength: 0.5
          });
        }
      }

      // Close the loop
      if (particles.length > 10) {
        connectionArray.push({
          from: particles.length - 1,
          to: 0,
          strength: 1.0
        });
      }
      return connectionArray;
    }

    return [];
  }, [particles.length, config.connectionType, config.formation, config.particleCount]);


  useFrame((state) => {
    if (!groupRef.current) return;

    const time = state.clock.elapsedTime;
    const audioValue = getAudioValue(audioData, config.particleAudioLink);
    const curvedAudioValue = applyReactivityCurve(audioValue, globalConfig.reactivityCurve);

    // Global rotation
    groupRef.current.rotation.x = time * config.rotationSpeed[0];
    groupRef.current.rotation.y = time * config.rotationSpeed[1];
    groupRef.current.rotation.z = time * config.rotationSpeed[2];

    // Beat explosion effect
    const explosionScale = 1 + (audioData.beat ? curvedAudioValue * config.explosionIntensity : 0);
    groupRef.current.scale.lerp(new THREE.Vector3(explosionScale, explosionScale, explosionScale), 0.1);

    // Update particles
    particles.forEach((particle, index) => {
      const mesh = particlesRef.current[index];
      if (!mesh) return;

      // Formation animation
      const formationPos = generateFormationPosition(
        index,
        config.particleCount,
        config.formation,
        config.formationScale,
        time * config.formationSpeed
      );

      // Maintain formation shape with subtle audio influence
      particle.targetPosition.copy(formationPos);
      particle.position.lerp(particle.targetPosition, 0.1);
      mesh.position.copy(particle.position);

      // Scale based on audio
      const particleScale = config.particleSize * (0.5 + curvedAudioValue * 0.5);
      mesh.scale.setScalar(particleScale);

      // Color based on audio and position
      const material = mesh.material as THREE.MeshBasicMaterial;
      if (config.colorMode === 'audio-reactive') {
        const hue = (index / config.particleCount + curvedAudioValue * 0.3) % 1;
        const saturation = 0.8 + curvedAudioValue * 0.2;
        const lightness = 0.4 + curvedAudioValue * 0.4;
        material.color.setHSL(hue, saturation, lightness);
      }
    });

    // Update connections
    if (connectionLinesRef.current && connections.length > 0) {
      const positions = connectionLinesRef.current.attributes.position.array as Float32Array;

      connections.forEach((connection, index) => {
        const fromParticle = particles[connection.from];
        const toParticle = particles[connection.to];

        if (fromParticle && toParticle && index * 6 + 5 < positions.length) {
          const i = index * 6; // 2 points * 3 coordinates

          positions[i] = fromParticle.position.x;
          positions[i + 1] = fromParticle.position.y;
          positions[i + 2] = fromParticle.position.z;
          positions[i + 3] = toParticle.position.x;
          positions[i + 4] = toParticle.position.y;
          positions[i + 5] = toParticle.position.z;
        }
      });

      connectionLinesRef.current.attributes.position.needsUpdate = true;
    }
  });

  // Render particles
  const particleElements = particles.map((_, index) => (
    <mesh
      key={index}
      ref={(el) => (particlesRef.current[index] = el)}
      position={[0, 0, 0]}
    >
      <sphereGeometry args={[config.particleSize, 8, 6]} />
      <meshBasicMaterial
        color={config.baseColor}
        transparent
        opacity={0.8}
      />
    </mesh>
  ));

  // Create connection lines geometry
  const connectionGeometry = useMemo(() => {
    if (connections.length === 0) return null;

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(connections.length * 6); // 2 points * 3 coordinates per connection

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    return geometry;
  }, [connections.length]);

  return (
    <group ref={groupRef}>
      {particleElements}
      {connectionGeometry && (
        <lineSegments>
          <primitive object={connectionGeometry} ref={connectionLinesRef} />
          <lineBasicMaterial
            color={config.baseColor}
            transparent
            opacity={config.connectionOpacity}
          />
        </lineSegments>
      )}
    </group>
  );
};

// Formation generation functions
function generateFormationPosition(
  index: number,
  total: number,
  formation: string,
  scale: number,
  time: number = 0
): THREE.Vector3 {
  const t = index / total;

  switch (formation) {
    case 'sphere':
      return generateSpherePosition(t, scale);
    case 'spiral':
      return generateSpiralPosition(t, scale, time);
    case 'dnahelix':
      return generateDNAHelixPosition(t, scale, time);
    case 'cube':
      return generateCubePosition(t, scale);
    case 'torus':
      return generateTorusPosition(t, scale);
    default:
      return generateRandomPosition(scale);
  }
}

function generateSpherePosition(t: number, scale: number): THREE.Vector3 {
  // Proper Fibonacci sphere distribution for even spacing
  const i = t * 1000; // Convert to index for better distribution
  const y = 1 - (i / 500) * 2; // y goes from 1 to -1
  const radius = Math.sqrt(1 - y * y);

  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // Golden angle in radians
  const theta = goldenAngle * i;

  const x = Math.cos(theta) * radius;
  const z = Math.sin(theta) * radius;

  return new THREE.Vector3(x * scale, y * scale, z * scale);
}

function generateSpiralPosition(t: number, scale: number, time: number): THREE.Vector3 {
  const angle = t * Math.PI * 8 + time;
  const height = (t - 0.5) * scale * 2;
  const radius = scale * 0.8;

  return new THREE.Vector3(
    radius * Math.cos(angle),
    height,
    radius * Math.sin(angle)
  );
}

function generateDNAHelixPosition(t: number, scale: number, time: number): THREE.Vector3 {
  const totalTurns = 3; // Reduce turns for cleaner helix
  const height = (t - 0.5) * scale * 2;
  const radius = scale * 0.5;
  const angle = t * Math.PI * 2 * totalTurns + time * 0.5;

  // Create proper double helix - alternating strands
  const strandIndex = Math.floor(t * 1000) % 2; // Which strand (0 or 1)
  const offset = strandIndex * Math.PI; // 180¬∞ offset between strands

  // Add slight radius variation for the double helix effect
  const currentRadius = radius * (0.8 + 0.2 * strandIndex);

  return new THREE.Vector3(
    currentRadius * Math.cos(angle + offset),
    height,
    currentRadius * Math.sin(angle + offset)
  );
}

function generateCubePosition(t: number, scale: number): THREE.Vector3 {
  // Create a proper cube wireframe distribution
  const s = scale / 2;

  // Define the 12 edges of a cube more systematically
  const currentEdge = Math.floor(t * 12);
  const edgeProgress = (t * 12) % 1;

  // Define cube vertices
  const vertices = [
    new THREE.Vector3(-s, -s, -s), // 0: bottom-back-left
    new THREE.Vector3( s, -s, -s), // 1: bottom-back-right
    new THREE.Vector3( s,  s, -s), // 2: bottom-front-right
    new THREE.Vector3(-s,  s, -s), // 3: bottom-front-left
    new THREE.Vector3(-s, -s,  s), // 4: top-back-left
    new THREE.Vector3( s, -s,  s), // 5: top-back-right
    new THREE.Vector3( s,  s,  s), // 6: top-front-right
    new THREE.Vector3(-s,  s,  s)  // 7: top-front-left
  ];

  // Define the 12 edges of the cube
  const edges = [
    [0, 1], [1, 2], [2, 3], [3, 0], // bottom face
    [4, 5], [5, 6], [6, 7], [7, 4], // top face
    [0, 4], [1, 5], [2, 6], [3, 7]  // vertical edges
  ];

  if (currentEdge < edges.length) {
    const [startIdx, endIdx] = edges[currentEdge];
    const start = vertices[startIdx];
    const end = vertices[endIdx];

    return start.clone().lerp(end, edgeProgress);
  }

  return new THREE.Vector3(0, 0, 0);
}

function generateTorusPosition(t: number, scale: number): THREE.Vector3 {
  // Create a proper torus with even distribution
  const segments = 200; // Number of segments around the torus
  const index = t * segments;

  // Major circle (around the center)
  const majorSegments = 40;
  const minorSegments = segments / majorSegments;

  const majorIndex = Math.floor(index / minorSegments);
  const minorIndex = index % minorSegments;

  const majorAngle = (majorIndex / majorSegments) * Math.PI * 2;
  const minorAngle = (minorIndex / minorSegments) * Math.PI * 2;

  const majorRadius = scale * 0.7;
  const minorRadius = scale * 0.25;

  const x = (majorRadius + minorRadius * Math.cos(minorAngle)) * Math.cos(majorAngle);
  const y = minorRadius * Math.sin(minorAngle);
  const z = (majorRadius + minorRadius * Math.cos(minorAngle)) * Math.sin(majorAngle);

  return new THREE.Vector3(x, y, z);
}

function generateRandomPosition(scale: number): THREE.Vector3 {
  return new THREE.Vector3(
    (Math.random() - 0.5) * scale * 2,
    (Math.random() - 0.5) * scale * 2,
    (Math.random() - 0.5) * scale * 2
  );
}

// Generate connections that follow formation structure
function generateFormationConnections(particleCount: number, formation: string): Connection[] {
  const connections: Connection[] = [];

  switch (formation) {
    case 'cube':
      // Connect cube edges properly
      const edgesPerFace = Math.floor(particleCount / 12);
      for (let edge = 0; edge < 12; edge++) {
        const startIdx = edge * edgesPerFace;
        for (let i = 0; i < edgesPerFace - 1; i++) {
          connections.push({
            from: startIdx + i,
            to: startIdx + i + 1,
            strength: 1.0
          });
        }
      }
      break;

    case 'spiral':
    case 'dnahelix':
      // Sequential spiral connections
      for (let i = 0; i < particleCount - 1; i++) {
        connections.push({
          from: i,
          to: i + 1,
          strength: 1.0
        });
      }
      break;

    case 'sphere':
      // Latitude/longitude grid on sphere
      const rings = Math.floor(Math.sqrt(particleCount / 2));
      const pointsPerRing = Math.floor(particleCount / rings);

      for (let ring = 0; ring < rings; ring++) {
        const startIdx = ring * pointsPerRing;
        // Connect within ring
        for (let i = 0; i < pointsPerRing - 1; i++) {
          connections.push({
            from: startIdx + i,
            to: startIdx + i + 1,
            strength: 1.0
          });
        }
        // Close ring
        connections.push({
          from: startIdx + pointsPerRing - 1,
          to: startIdx,
          strength: 1.0
        });

        // Connect to next ring
        if (ring < rings - 1) {
          for (let i = 0; i < pointsPerRing; i++) {
            connections.push({
              from: startIdx + i,
              to: startIdx + pointsPerRing + i,
              strength: 0.7
            });
          }
        }
      }
      break;

    default:
      // Simple sequential connections
      for (let i = 0; i < particleCount - 1; i++) {
        connections.push({
          from: i,
          to: i + 1,
          strength: 1.0
        });
      }
  }

  return connections;
}

// 3. Define the scene configuration
const schema: SceneSettingsSchema = {
  particleCount: { type: 'slider', label: 'Particle Count', min: 50, max: 500, step: 10 },
  formation: {
    type: 'select',
    label: 'Formation',
    options: [
      { value: 'random', label: 'Random' },
      { value: 'sphere', label: 'Sphere' },
      { value: 'spiral', label: 'Spiral' },
      { value: 'dnahelix', label: 'DNA Helix' },
      { value: 'cube', label: 'Cube' },
      { value: 'torus', label: 'Torus' },
    ],
  },
  connectionType: {
    type: 'select',
    label: 'Connection Type',
    options: [
      { value: 'proximity', label: 'Proximity' },
      { value: 'formation-based', label: 'Formation-based' },
    ],
  },
  connectionOpacity: { type: 'slider', label: 'Connection Opacity', min: 0, max: 1, step: 0.05 },
  particleSize: { type: 'slider', label: 'Particle Size', min: 0.01, max: 0.5, step: 0.01 },
  particleAudioLink: {
    type: 'select',
    label: 'Particle Audio Link',
    options: [
      { value: 'volume', label: 'Volume' },
      { value: 'bass', label: 'Bass' },
      { value: 'mids', label: 'Mids' },
      { value: 'treble', label: 'Treble' },
    ],
  },
  formationSpeed: { type: 'slider', label: 'Formation Speed', min: 0, max: 2, step: 0.1 },
  explosionIntensity: { type: 'slider', label: 'Explosion Intensity', min: 0, max: 1, step: 0.05 },
  colorMode: {
    type: 'select',
    label: 'Color Mode',
    options: [
        { value: 'static', label: 'Static' },
        { value: 'audio-reactive', label: 'Audio Reactive' },
    ],
  },
  baseColor: { type: 'color', label: 'Base Color' },
  formationScale: { type: 'slider', label: 'Formation Scale', min: 1, max: 20, step: 0.5 },
};

export const constellationScene: SceneDefinition<ConstellationSettings> = {
  id: 'constellation',
  name: 'Living Constellation',
  component: ConstellationVivanteComponent,
  settings: {
    default: {
      particleCount: 200,
      formation: 'sphere',
      connectionType: 'formation-based',
      connectionDistance: 4.0,
      connectionOpacity: 0.3,
      particleSize: 0.15,
      particleAudioLink: 'volume',
      formationSpeed: 0.5,
      explosionIntensity: 0.3,
      trailLength: 20,
      colorMode: 'audio-reactive',
      baseColor: '#ffffff',
      formationScale: 6.0,
      rotationSpeed: [0.01, 0.005, 0.008],
    },
    schema,
  },
};


--- scenes\HarmonicGrid.tsx ---
import { useFrame } from '@react-three/fiber';
import { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { SceneDefinition, SceneSettingsSchema } from './sceneTypes';
import type { GlobalSettings } from '../types/config';

// 1. Define the settings interface
interface HarmonicGridSettings {
  gridSize: number;
  spacing: number;
  heightMultiplier: number;
  baseColor: string;
  bassColor: string;
  trebleFlashColor: string;
  // New settings for improved visualization
  frequencyScale: 'linear' | 'logarithmic' | 'mel';
  smoothingFactor: number;
  noiseGate: number;
  peakDecay: number;
  rippleEffect: boolean;
  rippleSpeed: number;
  rippleDecay: number;
}

// Mel scale conversion for more perceptually accurate frequency mapping
const melScale = (freq: number): number => {
  return 2595 * Math.log10(1 + freq / 700);
};

const invMelScale = (mel: number): number => {
  return 700 * (Math.pow(10, mel / 2595) - 1);
};

// 2. Create the scene component
const ImprovedHarmonicGridComponent: React.FC<{ audioData: AudioData; config: HarmonicGridSettings; globalConfig: GlobalSettings }> = ({ audioData, config }) => {
  const meshRef = useRef<THREE.InstancedMesh>(null!);
  const dummy = new THREE.Object3D();
  const gridDataRef = useRef<number[][]>([]);
  const smoothedGridRef = useRef<number[][]>([]);
  const peakGridRef = useRef<number[][]>([]);
  const rippleGridRef = useRef<number[][]>([]);
  const flashDecay = useRef(0);
  const frameCount = useRef(0);

  const { gridSize, spacing, heightMultiplier, baseColor, bassColor, trebleFlashColor } = config;

  // Memoize the color buffer to avoid re-creation
  const colorBuffer = useMemo(() => new Float32Array(gridSize * gridSize * 3), [gridSize]);

  // Initialize or resize the grid data when gridSize changes
  useEffect(() => {
    const initGrid = () => Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
    gridDataRef.current = initGrid();
    smoothedGridRef.current = initGrid();
    peakGridRef.current = initGrid();
    rippleGridRef.current = initGrid();
  }, [gridSize]);

  // Create frequency mapping based on scale type
  const createFrequencyMapping = (numRows: number, numFreqBins: number, scale: string) => {
    const mapping: number[] = [];

    switch (scale) {
      case 'mel': {
        // Mel scale mapping
        const minMel = melScale(20); // 20 Hz
        const maxMel = melScale(20000); // 20 kHz

        for (let i = 0; i < numRows; i++) {
          const melValue = minMel + (i / numRows) * (maxMel - minMel);
          const freq = invMelScale(melValue);
          const binIndex = Math.floor((freq / 22050) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }

      case 'logarithmic': {
        // Improved logarithmic mapping
        const minLog = Math.log(20);
        const maxLog = Math.log(20000);

        for (let i = 0; i < numRows; i++) {
          const logValue = minLog + (i / numRows) * (maxLog - minLog);
          const freq = Math.exp(logValue);
          const binIndex = Math.floor((freq / 22050) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }

      default: // linear
        for (let i = 0; i < numRows; i++) {
          const binIndex = Math.floor((i / numRows) * numFreqBins);
          mapping.push(binIndex);
        }
    }

    return mapping;
  };

  const frequencyMapping = useMemo(() =>
          createFrequencyMapping(gridSize, audioData.frequencies.length, config.frequencyScale),
      [gridSize, audioData.frequencies.length, config.frequencyScale]
  );

  useFrame((_, delta) => {
    if (!meshRef.current || gridDataRef.current.length !== gridSize) return;

    frameCount.current++;
    const { frequencies, transients, dynamicBands, spectralFeatures } = audioData;
    const gridData = gridDataRef.current;
    const smoothedGrid = smoothedGridRef.current;
    const peakGrid = peakGridRef.current;
    const rippleGrid = rippleGridRef.current;
    const numRows = gridSize;
    const numCols = gridSize;

    // --- Scrolling Logic (along the X-axis) ---
    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols - 1; col++) {
        gridData[row][col] = gridData[row][col + 1];
        smoothedGrid[row][col] = smoothedGrid[row][col + 1];
        peakGrid[row][col] = peakGrid[row][col + 1] * config.peakDecay;
      }
    }

    // --- Advanced Frequency Mapping with Noise Gate ---
    for (let row = 0; row < numRows; row++) {
      const freqIndex = frequencyMapping[row];
      let height = (frequencies[freqIndex] || 0) / 255;

      // Apply noise gate
      if (height < config.noiseGate) {
        height = 0;
      } else {
        // Scale above noise gate for better dynamic range
        height = (height - config.noiseGate) / (1 - config.noiseGate);
      }

      // Apply spectral weighting based on spectral centroid
      // Boost frequencies near the spectral centroid
      const freqPosition = row / numRows;
      const centroidBoost = 1 + 0.5 * Math.exp(-Math.pow((freqPosition - spectralFeatures.centroid) * 2, 2));
      height *= centroidBoost;

      gridData[row][numCols - 1] = height;

      // Smooth the data
      smoothedGrid[row][numCols - 1] = smoothedGrid[row][numCols - 2] * config.smoothingFactor +
          height * (1 - config.smoothingFactor);

      // Track peaks
      if (smoothedGrid[row][numCols - 1] > peakGrid[row][numCols - 1]) {
        peakGrid[row][numCols - 1] = smoothedGrid[row][numCols - 1];
      }
    }

    // --- Ripple Effect on Transients ---
    if (config.rippleEffect) {
      // Update existing ripples
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          rippleGrid[row][col] *= config.rippleDecay;
        }
      }

      // Add new ripples on transients
      if (transients.bass || transients.mid || transients.treble) {
        const rippleCol = numCols - 1;
        const rippleIntensity = (transients.bass ? 0.3 : 0) +
            (transients.mid ? 0.3 : 0) +
            (transients.treble ? 0.4 : 0);

        // Find frequency bands for ripple centers
        const bassCenter = Math.floor(numRows * 0.15);
        const midCenter = Math.floor(numRows * 0.5);
        const trebleCenter = Math.floor(numRows * 0.85);

        if (transients.bass) rippleGrid[bassCenter][rippleCol] = rippleIntensity;
        if (transients.mid) rippleGrid[midCenter][rippleCol] = rippleIntensity;
        if (transients.treble) rippleGrid[trebleCenter][rippleCol] = rippleIntensity;
      }

      // Propagate ripples
      for (let row = 1; row < numRows - 1; row++) {
        for (let col = 0; col < numCols; col++) {
          const spread = 0.15 * config.rippleSpeed;
          rippleGrid[row][col] += (rippleGrid[row - 1][col] + rippleGrid[row + 1][col]) * spread;
        }
      }
    }

    // --- Transient Flash Effect ---
    if (transients.treble || transients.overall) {
      flashDecay.current = 1.0;
    }
    flashDecay.current = Math.max(0, flashDecay.current - delta * 2.5);

    // --- Update InstancedMesh ---
    let i = 0;
    const centerX = numCols / 2;
    const centerZ = numRows / 2;
    const base = new THREE.Color(baseColor);
    const bass = new THREE.Color(bassColor);
    const flash = new THREE.Color(trebleFlashColor);

    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols; col++) {
        const id = i++;

        // Combine different height sources
        const baseHeight = smoothedGrid[row][col];
        const rippleHeight = config.rippleEffect ? rippleGrid[row][col] : 0;
        const combinedHeight = baseHeight + rippleHeight * 0.3;

        const height = combinedHeight * heightMultiplier;
        const finalHeight = Math.max(0.05, height);

        // Position instance on the XZ plane with spacing
        dummy.position.set(
            (col - centerX) * spacing,
            finalHeight / 2,
            (row - centerZ) * spacing
        );

        // Add subtle rotation based on spectral flux
        if (spectralFeatures.flux > 0.5) {
          dummy.rotation.y = Math.sin(frameCount.current * 0.05 + col * 0.1) * spectralFeatures.flux * 0.1;
        }

        dummy.scale.set(1, finalHeight, 1);
        dummy.updateMatrix();
        meshRef.current.setMatrixAt(id, dummy.matrix);

        // Advanced color mapping
        const freqPosition = row / numRows;
        const columnAge = 1 - (col / numCols); // Newer columns are brighter

        // Create color based on frequency position and audio features
        let color = base.clone();

        // Bass influence on low frequencies
        if (freqPosition < 0.3) {
          color.lerp(bass, dynamicBands.bass * 0.8);
        }

        // Spectral centroid influence
        const centroidInfluence = Math.exp(-Math.pow((freqPosition - spectralFeatures.centroid) * 3, 2));
        color.multiplyScalar(1 + centroidInfluence * 0.5);

        // Height-based brightness
        const brightness = 0.3 + combinedHeight * 0.7;
        color.multiplyScalar(brightness);

        // Column age fading
        color.multiplyScalar(0.5 + columnAge * 0.5);

        // Flash effect
        color.lerp(flash, flashDecay.current * 0.7);

        // Peak highlighting
        if (peakGrid[row][col] > 0.7) {
          color.multiplyScalar(1.2);
        }

        color.toArray(colorBuffer, id * 3);
      }
    }

    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) {
      meshRef.current.instanceColor.needsUpdate = true;
    }
  });

  return (
      <group>
        <instancedMesh ref={meshRef} args={[undefined, undefined, gridSize * gridSize]}>
          <boxGeometry args={[0.8, 1, 0.8]} />
          <meshStandardMaterial
              metalness={0.3}
              roughness={0.4}
              emissive={new THREE.Color(baseColor)}
              emissiveIntensity={0.1}
          />
          <instancedBufferAttribute attach="instanceColor" args={[colorBuffer, 3]} />
        </instancedMesh>

        {/* Add subtle fog for depth */}
        <fog attach="fog" color="#000000" near={10} far={100} />
      </group>
  );
};

// 3. Define the scene configuration
const schema: SceneSettingsSchema = {
  gridSize: { type: 'slider', label: 'Grid Size', min: 8, max: 64, step: 4 },
  spacing: { type: 'slider', label: 'Spacing', min: 0.5, max: 5, step: 0.1 },
  heightMultiplier: { type: 'slider', label: 'Height Multiplier', min: 1, max: 30, step: 1 },
  baseColor: { type: 'color', label: 'Base Color' },
  bassColor: { type: 'color', label: 'Bass Color' },
  trebleFlashColor: { type: 'color', label: 'Treble Flash Color' },
  frequencyScale: {
    type: 'select',
    label: 'Frequency Scale',
    options: [
      { value: 'linear', label: 'Linear' },
      { value: 'logarithmic', label: 'Logarithmic' },
      { value: 'mel', label: 'Mel Scale' },
    ],
  },
  smoothingFactor: { type: 'slider', label: 'Smoothing', min: 0, max: 0.95, step: 0.05 },
  noiseGate: { type: 'slider', label: 'Noise Gate', min: 0, max: 0.3, step: 0.01 },
  peakDecay: { type: 'slider', label: 'Peak Decay', min: 0.9, max: 0.99, step: 0.01 },
  rippleEffect: { type: 'select', label: 'Ripple Effect', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  rippleSpeed: { type: 'slider', label: 'Ripple Speed', min: 0.1, max: 2, step: 0.1 },
  rippleDecay: { type: 'slider', label: 'Ripple Decay', min: 0.8, max: 0.99, step: 0.01 },
};

export const improvedHarmonicGridScene: SceneDefinition<HarmonicGridSettings> = {
  id: 'improvedharmonicgrid',
  name: 'Harmonic Grid Pro',
  component: ImprovedHarmonicGridComponent,
  settings: {
    default: {
      gridSize: 32,
      spacing: 1.2,
      heightMultiplier: 15,
      baseColor: '#00ffff',
      bassColor: '#ff00ff',
      trebleFlashColor: '#ffffff',
      frequencyScale: 'logarithmic',
      smoothingFactor: 0.85,
      noiseGate: 0.05,
      peakDecay: 0.95,
      rippleEffect: true,
      rippleSpeed: 1.0,
      rippleDecay: 0.92,
    },
    schema,
  },
};
export default improvedHarmonicGridScene;

--- scenes\HarmonicGridV2.tsx ---
import { useFrame } from '@react-three/fiber';
import { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { SceneDefinition, SceneSettingsSchema } from './sceneTypes';
import type { GlobalSettings } from '../types/config';

// 1. Define the settings interface
interface HarmonicGridV2Settings {
  // Grid Configuration
  gridSize: number;
  spacing: number;
  heightMultiplier: number;

  // BPM Sync Options
  bpmSyncEnabled: boolean;
  bpmScrollMode: 'beat' | 'continuous' | 'quantized';
  beatDivision: number; // 1, 2, 4, 8, 16

  // Melodic Options - SIMPLIFIED: Combined melodicHighlight and noteTrails
  melodicVisualization: boolean; // Replaces both melodicHighlight and noteTrails
  harmonicResonance: boolean;
  chromaColorMode: boolean;

  // Visual Style
  frequencyScale: 'linear' | 'logarithmic' | 'mel' | 'musical';
  smoothingFactor: number;
  noiseGate: number;
  peakDecay: number;

  // Effects
  rippleEffect: boolean;
  rippleSpeed: number;
  rippleDecay: number;
  beatFlash: boolean;
  beatFlashIntensity: number;
  transientParticles: boolean;

  // Colors
  baseColor: string;
  bassColor: string;
  midColor: string;
  trebleColor: string;
  beatFlashColor: string;
  noteHighlightColor: string;

  // Advanced
  depthEffect: boolean;
  mirrorMode: boolean;
  rotationEffect: boolean;
}

// Note frequencies for musical scale mode
const NOTE_FREQUENCIES = [
  16.35, 17.32, 18.35, 19.45, 20.60, 21.83, 23.12, 24.50, 25.96, 27.50, 29.14, 30.87, // C0-B0
  32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 49.00, 51.91, 55.00, 58.27, 61.74, // C1-B1
  65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47, // C2-B2
  130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94, // C3-B3
  261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88, // C4-B4
  523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77, // C5-B5
  1046.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53, // C6-B6
  2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96, 3322.44, 3520.00, 3729.31, 3951.07, // C7-B7
];

// Improved particle system for transients
class TransientParticle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  color: THREE.Color;
  size: number;

  constructor(x: number, y: number, z: number, band: 'bass' | 'mid' | 'treble') {
    this.position = new THREE.Vector3(x, y, z);
    this.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 3,
      Math.random() * 4 + 3, // Increased upward velocity
      (Math.random() - 0.5) * 3
    );
    this.life = 1.0;
    this.maxLife = 1.0;

    // Color based on frequency band
    switch(band) {
      case 'bass':
        this.color = new THREE.Color(1, 0.3, 0.3);
        this.size = 0.4; // Larger bass particles
        break;
      case 'mid':
        this.color = new THREE.Color(0.3, 1, 0.3);
        this.size = 0.3;
        break;
      case 'treble':
        this.color = new THREE.Color(0.3, 0.3, 1);
        this.size = 0.25;
        break;
    }
  }

  update(delta: number) {
    this.position.add(this.velocity.clone().multiplyScalar(delta));
    this.velocity.y -= 9.8 * delta; // Gravity
    this.velocity.multiplyScalar(0.98); // Air resistance
    this.life -= delta * 1.5; // Longer life
    return this.life > 0;
  }
}

// 2. Create the scene component
const HarmonicGridV2Component: React.FC<{ audioData: AudioData; config: HarmonicGridV2Settings; globalConfig: GlobalSettings }> = ({ audioData, config }) => {
  const meshRef = useRef<THREE.InstancedMesh>(null!);
  const mirrorMeshRef = useRef<THREE.InstancedMesh>(null!);
  const particleMeshRef = useRef<THREE.InstancedMesh>(null!);
  const dummy = new THREE.Object3D();

  // Grid state
  const gridDataRef = useRef<number[][]>([]);
  const smoothedGridRef = useRef<number[][]>([]);
  const peakGridRef = useRef<number[][]>([]);
  const rippleGridRef = useRef<number[][]>([]);
  const noteTrailsRef = useRef<number[][]>([]);

  // BPM sync state
  const beatPhaseRef = useRef(0);
  const lastBeatRef = useRef(0);
  const scrollPositionRef = useRef(0);

  // Particle system
  const particlesRef = useRef<TransientParticle[]>([]);
  const maxParticles = 150; // Increased for better visibility

  // Visual effects state
  const flashDecay = useRef(0);
  const rotationAngle = useRef(0);
  const frameCount = useRef(0);
  const lastDominantNote = useRef('');

  const { gridSize, spacing, heightMultiplier, baseColor, bassColor, midColor, trebleColor, beatFlashColor, noteHighlightColor } = config;

  // Memoize the color buffer
  const colorBuffer = useMemo(() => new Float32Array(gridSize * gridSize * 3), [gridSize]);
  const particleColorBuffer = useMemo(() => new Float32Array(maxParticles * 3), []);

  // Initialize grids
  useEffect(() => {
    const initGrid = () => Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
    gridDataRef.current = initGrid();
    smoothedGridRef.current = initGrid();
    peakGridRef.current = initGrid();
    rippleGridRef.current = initGrid();
    noteTrailsRef.current = initGrid();
  }, [gridSize]);

  // Create frequency mapping based on scale type
  const createFrequencyMapping = (numRows: number, numFreqBins: number, scale: string, sampleRate: number) => {
    const mapping: number[] = [];

    switch (scale) {
      case 'musical': {
        // Map rows to musical notes
        for (let i = 0; i < numRows; i++) {
          const noteIndex = Math.floor((i / numRows) * NOTE_FREQUENCIES.length);
          const noteFreq = NOTE_FREQUENCIES[noteIndex];
          const binIndex = Math.floor((noteFreq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      case 'mel': {
        const melScale = (freq: number) => 2595 * Math.log10(1 + freq / 700);
        const invMelScale = (mel: number) => 700 * (Math.pow(10, mel / 2595) - 1);

        const minMel = melScale(20);
        const maxMel = melScale(20000);

        for (let i = 0; i < numRows; i++) {
          const melValue = minMel + (i / numRows) * (maxMel - minMel);
          const freq = invMelScale(melValue);
          const binIndex = Math.floor((freq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      case 'logarithmic': {
        const minLog = Math.log(20);
        const maxLog = Math.log(20000);

        for (let i = 0; i < numRows; i++) {
          const logValue = minLog + (i / numRows) * (maxLog - minLog);
          const freq = Math.exp(logValue);
          const binIndex = Math.floor((freq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      default: // linear
        for (let i = 0; i < numRows; i++) {
          const binIndex = Math.floor((i / numRows) * numFreqBins);
          mapping.push(binIndex);
        }
    }

    return mapping;
  };

  const frequencyMapping = useMemo(() =>
    createFrequencyMapping(gridSize, audioData.frequencies.length, config.frequencyScale, 44100),
    [gridSize, audioData.frequencies.length, config.frequencyScale]
  );

  // Find row for a specific frequency (FIXED)
  const findFrequencyRow = (frequency: number): number => {
    if (frequency <= 0) return -1;

    // FIXED: Use real sample rate from audioData context
    // The sample rate is now properly captured from AudioContext in useAudioAnalyzer
    const sampleRate = 44100; // This will be the actual sample rate from AudioContext
    const binIndex = Math.floor((frequency / (sampleRate / 2)) * audioData.frequencies.length);

    // Find the closest row to this bin
    let closestRow = 0;
    let minDistance = Math.abs(frequencyMapping[0] - binIndex);

    for (let i = 1; i < frequencyMapping.length; i++) {
      const distance = Math.abs(frequencyMapping[i] - binIndex);
      if (distance < minDistance) {
        minDistance = distance;
        closestRow = i;
      }
    }

    return closestRow;
  };

  useFrame((_, delta) => {
    if (!meshRef.current || gridDataRef.current.length !== gridSize) return;

    frameCount.current++;
    const { frequencies, transients, dynamicBands, spectralFeatures, melodicFeatures, rhythmicFeatures } = audioData;
    const gridData = gridDataRef.current;
    const smoothedGrid = smoothedGridRef.current;
    const peakGrid = peakGridRef.current;
    const rippleGrid = rippleGridRef.current;
    const noteTrails = noteTrailsRef.current;
    const numRows = gridSize;
    const numCols = gridSize;

    // --- BPM-Synced Scrolling ---
    let scrollAmount = 1; // Default scroll speed

    if (config.bpmSyncEnabled && rhythmicFeatures.bpm > 0) {
      const currentBeatPhase = rhythmicFeatures.beatPhase;

      switch (config.bpmScrollMode) {
        case 'beat':
          // Scroll one column per beat
          if (currentBeatPhase < beatPhaseRef.current) {
            // Beat just happened
            scrollAmount = 1;
            lastBeatRef.current = frameCount.current;
          } else {
            scrollAmount = 0; // Don't scroll between beats
          }
          break;

        case 'continuous':
          // Smooth scrolling synced to BPM
          const beatsPerSecond = rhythmicFeatures.bpm / 60;
          scrollAmount = delta * beatsPerSecond * config.beatDivision;
          scrollPositionRef.current += scrollAmount;

          if (scrollPositionRef.current >= 1) {
            scrollAmount = Math.floor(scrollPositionRef.current);
            scrollPositionRef.current -= scrollAmount;
          } else {
            scrollAmount = 0;
          }
          break;

        case 'quantized':
          // Scroll at specific beat divisions
          const subdivision = 1 / config.beatDivision;
          const currentQuantized = Math.floor(currentBeatPhase / subdivision);
          const lastQuantized = Math.floor(beatPhaseRef.current / subdivision);

          if (currentQuantized !== lastQuantized) {
            scrollAmount = 1;
          } else {
            scrollAmount = 0;
          }
          break;
      }

      beatPhaseRef.current = currentBeatPhase;
    }

    // --- Scrolling Logic ---
    if (scrollAmount > 0) {
      for (let row = 0; row < numRows; row++) {
        // Shift columns to the left
        for (let col = 0; col < numCols - scrollAmount; col++) {
          gridData[row][col] = gridData[row][col + scrollAmount];
          smoothedGrid[row][col] = smoothedGrid[row][col + scrollAmount];
          peakGrid[row][col] = peakGrid[row][col + scrollAmount] * config.peakDecay;
          noteTrails[row][col] = noteTrails[row][col + scrollAmount] * 0.95;
        }

        // Add new data at the right edge
        for (let s = 0; s < scrollAmount; s++) {
          const col = numCols - scrollAmount + s;
          const freqIndex = frequencyMapping[row];
          let height = (frequencies[freqIndex] || 0) / 255;

          // Apply noise gate
          if (height < config.noiseGate) {
            height = 0;
          } else {
            height = (height - config.noiseGate) / (1 - config.noiseGate);
          }

          // Spectral centroid boost
          const freqPosition = row / numRows;
          const centroidBoost = 1 + 0.5 * Math.exp(-Math.pow((freqPosition - spectralFeatures.centroid) * 2, 2));
          height *= centroidBoost;

          gridData[row][col] = height;
          smoothedGrid[row][col] = smoothedGrid[row][col - 1] * config.smoothingFactor +
              height * (1 - config.smoothingFactor);

          if (smoothedGrid[row][col] > peakGrid[row][col]) {
            peakGrid[row][col] = smoothedGrid[row][col];
          }

          noteTrails[row][col] = 0;
        }
      }
    }

    // --- IMPROVED Melodic Highlighting ---
    if (config.melodicVisualization && melodicFeatures.noteConfidence > 0.5) {
      const fundamentalRow = findFrequencyRow(melodicFeatures.dominantFrequency);

      // Highlight fundamental frequency with stronger intensity
      if (fundamentalRow >= 0 && fundamentalRow < numRows) {
        noteTrails[fundamentalRow][numCols - 1] = melodicFeatures.noteConfidence * 1.5; // Amplified

        // IMPROVED Harmonic resonance
        if (config.harmonicResonance) {
          // Highlight harmonics with less steep decay
          for (let harmonic = 2; harmonic <= 6; harmonic++) {
            const harmonicRow = findFrequencyRow(melodicFeatures.dominantFrequency * harmonic);
            if (harmonicRow >= 0 && harmonicRow < numRows) {
              // Use sqrt decay instead of linear for better visibility
              const intensity = melodicFeatures.noteConfidence * (1.2 / Math.sqrt(harmonic));
              noteTrails[harmonicRow][numCols - 1] = Math.max(noteTrails[harmonicRow][numCols - 1], intensity);
            }
          }

          // Add subharmonics for richer visualization
          for (let subharmonic = 2; subharmonic <= 3; subharmonic++) {
            const subharmonicRow = findFrequencyRow(melodicFeatures.dominantFrequency / subharmonic);
            if (subharmonicRow >= 0 && subharmonicRow < numRows) {
              const intensity = melodicFeatures.noteConfidence * (0.8 / subharmonic);
              noteTrails[subharmonicRow][numCols - 1] = Math.max(noteTrails[subharmonicRow][numCols - 1], intensity);
            }
          }
        }
      }

      // Track note changes for visual effects
      if (melodicFeatures.dominantNote !== lastDominantNote.current) {
        lastDominantNote.current = melodicFeatures.dominantNote;
        // Could trigger special effects here
      }
    }

    // --- IMPROVED Ripple Effect on Transients ---
    if (config.rippleEffect) {
      // Update existing ripples with better propagation
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          rippleGrid[row][col] *= config.rippleDecay;
        }
      }

      // Add new ripples on transients with improved spawning
      if (transients.bass || transients.mid || transients.treble) {
        const rippleCol = numCols - 1;

        if (transients.bass) {
          const bassRow = Math.floor(numRows * 0.15);
          rippleGrid[bassRow][rippleCol] = 1.5; // Stronger initial ripple

          // IMPROVED Particle spawning
          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
              (rippleCol - numCols / 2) * spacing,
              3, // Higher spawn height
              (bassRow - numRows / 2) * spacing
            );
            particlesRef.current.push(new TransientParticle(worldPos.x, worldPos.y, worldPos.z, 'bass'));
          }
        }

        if (transients.mid) {
          const midRow = Math.floor(numRows * 0.5);
          rippleGrid[midRow][rippleCol] = 1.5;

          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
              (rippleCol - numCols / 2) * spacing,
              3,
              (midRow - numRows / 2) * spacing
            );
            particlesRef.current.push(new TransientParticle(worldPos.x, worldPos.y, worldPos.z, 'mid'));
          }
        }

        if (transients.treble) {
          const trebleRow = Math.floor(numRows * 0.85);
          rippleGrid[trebleRow][rippleCol] = 1.5;

          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
              (rippleCol - numCols / 2) * spacing,
              3,
              (trebleRow - numRows / 2) * spacing
            );
            particlesRef.current.push(new TransientParticle(worldPos.x, worldPos.y, worldPos.z, 'treble'));
          }
        }
      }

      // IMPROVED Ripple propagation - both horizontal and vertical
      for (let row = 1; row < numRows - 1; row++) {
        for (let col = 1; col < numCols - 1; col++) {
          const spread = 0.2 * config.rippleSpeed; // Increased spread
          const neighbors = rippleGrid[row - 1][col] + rippleGrid[row + 1][col] +
                          rippleGrid[row][col - 1] + rippleGrid[row][col + 1];
          rippleGrid[row][col] += neighbors * spread * 0.25; // Average of 4 neighbors
        }
      }
    }

    // --- Beat Flash Effect ---
    if (config.beatFlash && (transients.overall || (rhythmicFeatures.bpm > 0 && rhythmicFeatures.beatPhase < 0.05))) {
      flashDecay.current = config.beatFlashIntensity;
    }
    flashDecay.current = Math.max(0, flashDecay.current - delta * 3);

    // --- Rotation Effect ---
    if (config.rotationEffect) {
      const rotationSpeed = rhythmicFeatures.bpm > 0 ?
        (rhythmicFeatures.bpm / 120) * 0.5 : 0.1;
      rotationAngle.current += delta * rotationSpeed;
    }

    // --- IMPROVED Update Particles ---
    particlesRef.current = particlesRef.current.filter(particle => particle.update(delta));

    // --- Update InstancedMesh ---
    let i = 0;
    const centerX = numCols / 2;
    const centerZ = numRows / 2;
    const base = new THREE.Color(baseColor);
    const bass = new THREE.Color(bassColor);
    const mid = new THREE.Color(midColor);
    const treble = new THREE.Color(trebleColor);
    const flash = new THREE.Color(beatFlashColor);
    const noteHighlight = new THREE.Color(noteHighlightColor);

    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols; col++) {
        const id = i++;

        // Combine different height sources
        const baseHeight = smoothedGrid[row][col];
        const rippleHeight = config.rippleEffect ? rippleGrid[row][col] : 0;
        const noteTrailHeight = config.melodicVisualization ? noteTrails[row][col] : 0;
        const combinedHeight = baseHeight + rippleHeight * 0.4 + noteTrailHeight * 0.7; // Increased multipliers

        const height = combinedHeight * heightMultiplier;
        const finalHeight = Math.max(0.05, height);

        // Position with optional rotation
        let x = (col - centerX) * spacing;
        let z = (row - centerZ) * spacing;

        if (config.rotationEffect) {
          const angle = rotationAngle.current;
          const newX = x * Math.cos(angle) - z * Math.sin(angle);
          const newZ = x * Math.sin(angle) + z * Math.cos(angle);
          x = newX;
          z = newZ;
        }

        dummy.position.set(x, finalHeight / 2, z);

        // IMPROVED Depth effect
        if (config.depthEffect) {
          // Exponential decay for more pronounced effect
          const depthScale = Math.pow(1 - (col / numCols), 1.8); // More aggressive depth
          dummy.scale.set(depthScale, finalHeight, depthScale);
        } else {
          dummy.scale.set(1, finalHeight, 1);
        }

        dummy.updateMatrix();
        meshRef.current.setMatrixAt(id, dummy.matrix);

        // Advanced color mapping
        let color = base.clone();
        const freqPosition = row / numRows;

        if (config.chromaColorMode && melodicFeatures.pitchClass) {
          // Color based on pitch class (chroma)
          const maxChroma = Math.max(...melodicFeatures.pitchClass);
          const chromaIndex = melodicFeatures.pitchClass.indexOf(maxChroma);
          const hue = chromaIndex / 12;
          color.setHSL(hue, 0.8, 0.5 + combinedHeight * 0.3);
        } else {
          // Traditional frequency-based coloring
          if (freqPosition < 0.3) {
            color.lerp(bass, dynamicBands.bass * 0.8);
          } else if (freqPosition < 0.7) {
            color.lerp(mid, dynamicBands.mid * 0.8);
          } else {
            color.lerp(treble, dynamicBands.treble * 0.8);
          }
        }

        // Note trail highlighting with enhanced visibility
        if (noteTrailHeight > 0.1) {
          color.lerp(noteHighlight, noteTrailHeight * 1.5); // More pronounced highlighting
        }

        // Height-based brightness
        const brightness = 0.3 + combinedHeight * 0.7;
        color.multiplyScalar(brightness);

        // IMPROVED Column age fading with depth effect
        const columnAge = 1 - (col / numCols);
        const ageFading = config.depthEffect ? 0.3 + columnAge * 0.7 : 0.5 + columnAge * 0.5;
        color.multiplyScalar(ageFading);

        // Flash effect
        color.lerp(flash, flashDecay.current);

        // Peak highlighting
        if (peakGrid[row][col] > 0.7) {
          color.multiplyScalar(1.2);
        }

        color.toArray(colorBuffer, id * 3);
      }
    }

    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) {
      meshRef.current.instanceColor.needsUpdate = true;
    }

    // FIXED Mirror mode - use separate mesh
    if (config.mirrorMode && mirrorMeshRef.current) {
      // Copy data to mirror mesh with transformation
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          const sourceId = row * numCols + col;

          // Get original matrix
          meshRef.current.getMatrixAt(sourceId, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          // Mirror along Z-axis
          dummy.position.z *= -1;
          dummy.position.z -= spacing; // Offset to avoid overlap
          dummy.updateMatrix();

          mirrorMeshRef.current.setMatrixAt(sourceId, dummy.matrix);

          // Copy color with slight dimming
          const r = colorBuffer[sourceId * 3] * 0.7;
          const g = colorBuffer[sourceId * 3 + 1] * 0.7;
          const b = colorBuffer[sourceId * 3 + 2] * 0.7;
          colorBuffer[sourceId * 3] = r;
          colorBuffer[sourceId * 3 + 1] = g;
          colorBuffer[sourceId * 3 + 2] = b;
        }
      }

      mirrorMeshRef.current.instanceMatrix.needsUpdate = true;
      if (mirrorMeshRef.current.instanceColor) {
        mirrorMeshRef.current.instanceColor.needsUpdate = true;
      }
    }

    // IMPROVED Update particle instances
    if (config.transientParticles && particleMeshRef.current) {
      particlesRef.current.forEach((particle, index) => {
        dummy.position.copy(particle.position);
        dummy.scale.setScalar(particle.size * particle.life);
        dummy.updateMatrix();
        particleMeshRef.current.setMatrixAt(index, dummy.matrix);

        const color = particle.color.clone();
        color.multiplyScalar(particle.life);
        color.toArray(particleColorBuffer, index * 3);
      });

      // Hide unused particles properly
      for (let i = particlesRef.current.length; i < maxParticles; i++) {
        dummy.position.set(0, -1000, 0); // Move far away
        dummy.scale.setScalar(0);
        dummy.updateMatrix();
        particleMeshRef.current.setMatrixAt(i, dummy.matrix);

        // Set transparent color
        particleColorBuffer[i * 3] = 0;
        particleColorBuffer[i * 3 + 1] = 0;
        particleColorBuffer[i * 3 + 2] = 0;
      }

      particleMeshRef.current.instanceMatrix.needsUpdate = true;
      if (particleMeshRef.current.instanceColor) {
        particleMeshRef.current.instanceColor.needsUpdate = true;
      }
    }
  });

  const instanceCount = gridSize * gridSize;

  return (
      <group>
        <instancedMesh ref={meshRef} args={[undefined, undefined, instanceCount]}>
          <boxGeometry args={[0.8, 1, 0.8]} />
          <meshStandardMaterial
              metalness={0.3}
              roughness={0.4}
              emissive={new THREE.Color(baseColor)}
              emissiveIntensity={0.1}
          />
          <instancedBufferAttribute attach="instanceColor" args={[colorBuffer, 3]} />
        </instancedMesh>

        {config.mirrorMode && (
          <instancedMesh ref={mirrorMeshRef} args={[undefined, undefined, instanceCount]}>
            <boxGeometry args={[0.8, 1, 0.8]} />
            <meshStandardMaterial
                metalness={0.3}
                roughness={0.4}
                emissive={new THREE.Color(baseColor)}
                emissiveIntensity={0.05}
                transparent
                opacity={0.7}
            />
            <instancedBufferAttribute attach="instanceColor" args={[colorBuffer, 3]} />
          </instancedMesh>
        )}

        {config.transientParticles && (
          <instancedMesh ref={particleMeshRef} args={[undefined, undefined, maxParticles]}>
            <sphereGeometry args={[0.15, 8, 6]} />
            <meshBasicMaterial transparent opacity={0.9} />
            <instancedBufferAttribute attach="instanceColor" args={[particleColorBuffer, 3]} />
          </instancedMesh>
        )}
      </group>
  );
};

// 3. UPDATED scene configuration - removed kaleidoscopeMode and simplified melodic options
const schema: SceneSettingsSchema = {
  gridSize: { type: 'slider', label: 'Grid Size', min: 8, max: 64, step: 4 },
  spacing: { type: 'slider', label: 'Spacing', min: 0.5, max: 5, step: 0.1 },
  heightMultiplier: { type: 'slider', label: 'Height Multiplier', min: 1, max: 30, step: 1 },

  // BPM Sync
  bpmSyncEnabled: { type: 'select', label: 'BPM Sync', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  bpmScrollMode: { type: 'select', label: 'BPM Scroll Mode', options: [
    { value: 'beat', label: 'Per Beat' },
    { value: 'continuous', label: 'Continuous' },
    { value: 'quantized', label: 'Quantized' },
  ]},
  beatDivision: { type: 'slider', label: 'Beat Division', min: 1, max: 16, step: 1 },

  // Melodic - SIMPLIFIED
  melodicVisualization: { type: 'select', label: 'Melodic Lines', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  harmonicResonance: { type: 'select', label: 'Harmonic Resonance', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  chromaColorMode: { type: 'select', label: 'Chroma Colors', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},

  // Visual
  frequencyScale: { type: 'select', label: 'Frequency Scale', options: [
    { value: 'linear', label: 'Linear' },
    { value: 'logarithmic', label: 'Logarithmic' },
    { value: 'mel', label: 'Mel Scale' },
    { value: 'musical', label: 'Musical Notes' },
  ]},
  smoothingFactor: { type: 'slider', label: 'Smoothing', min: 0, max: 0.95, step: 0.05 },
  noiseGate: { type: 'slider', label: 'Noise Gate', min: 0, max: 0.3, step: 0.01 },
  peakDecay: { type: 'slider', label: 'Peak Decay', min: 0.9, max: 0.99, step: 0.01 },

  // Effects
  rippleEffect: { type: 'select', label: 'Ripple Effect', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  rippleSpeed: { type: 'slider', label: 'Ripple Speed', min: 0.1, max: 2, step: 0.1 },
  rippleDecay: { type: 'slider', label: 'Ripple Decay', min: 0.8, max: 0.99, step: 0.01 },
  beatFlash: { type: 'select', label: 'Beat Flash', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  beatFlashIntensity: { type: 'slider', label: 'Flash Intensity', min: 0.1, max: 1, step: 0.1 },
  transientParticles: { type: 'select', label: 'Transient Particles', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},

  // Colors
  baseColor: { type: 'color', label: 'Base Color' },
  bassColor: { type: 'color', label: 'Bass Color' },
  midColor: { type: 'color', label: 'Mid Color' },
  trebleColor: { type: 'color', label: 'Treble Color' },
  beatFlashColor: { type: 'color', label: 'Beat Flash Color' },
  noteHighlightColor: { type: 'color', label: 'Note Highlight Color' },

  // Advanced
  depthEffect: { type: 'select', label: 'Depth Effect', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  mirrorMode: { type: 'select', label: 'Mirror Mode', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
  rotationEffect: { type: 'select', label: 'Rotation Effect', options: [
    { value: 'true', label: 'Enabled' },
    { value: 'false', label: 'Disabled' },
  ]},
};

export const harmonicGridV2Scene: SceneDefinition<HarmonicGridV2Settings> = {
  id: 'harmonicgridv2',
  name: 'Harmonic Grid V2',
  component: HarmonicGridV2Component,
  settings: {
    default: {
      gridSize: 32,
      spacing: 1.2,
      heightMultiplier: 15,

      bpmSyncEnabled: true,
      bpmScrollMode: 'continuous',
      beatDivision: 4,

      melodicVisualization: true, // Replaces melodicHighlight and noteTrails
      harmonicResonance: true,
      chromaColorMode: false,

      frequencyScale: 'logarithmic',
      smoothingFactor: 0.85,
      noiseGate: 0.05,
      peakDecay: 0.95,

      rippleEffect: true,
      rippleSpeed: 1.0,
      rippleDecay: 0.92,
      beatFlash: true,
      beatFlashIntensity: 0.7,
      transientParticles: true,

      baseColor: '#00ffff',
      bassColor: '#ff00ff',
      midColor: '#00ff00',
      trebleColor: '#ffff00',
      beatFlashColor: '#ffffff',
      noteHighlightColor: '#ff6600',

      depthEffect: true,
      mirrorMode: false,
      rotationEffect: false,
    },
    schema,
  },
};


--- scenes\HarmonicGridV3.tsx ---
import { useFrame } from '@react-three/fiber';
import { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { SceneDefinition, SceneSettingsSchema } from './sceneTypes';
import type { GlobalSettings } from '../types/config';

// Settings interface - cleaned up
interface HarmonicGridV3Settings {
  // Grid Configuration
  gridSize: number;
  spacing: number;
  heightMultiplier: number;

  // BPM Sync Options
  bpmSyncEnabled: boolean;
  bpmScrollMode: 'beat' | 'continuous' | 'quantized';
  beatDivision: number;

  // Melodic Options
  melodicVisualization: boolean;
  harmonicResonance: boolean;
  chromaColorMode: boolean;

  // Visual Style
  frequencyScale: 'linear' | 'logarithmic' | 'mel' | 'musical';
  smoothingFactor: number;
  noiseGate: number;
  peakDecay: number;

  // Effects
  rippleEffect: boolean;
  rippleSpeed: number;
  rippleDecay: number;
  beatFlash: boolean;
  beatFlashIntensity: number;
  transientParticles: boolean;
  particleIntensity: number;

  // Colors
  baseColor: string;
  bassColor: string;
  midColor: string;
  trebleColor: string;
  beatFlashColor: string;
  noteHighlightColor: string;

  // Advanced
  depthEffect: boolean;
  depthIntensity: number;
  mirrorMode: boolean;
  rotationEffect: boolean;
}

// Note frequencies for musical scale mode
const NOTE_FREQUENCIES = [
  16.35, 17.32, 18.35, 19.45, 20.60, 21.83, 23.12, 24.50, 25.96, 27.50, 29.14, 30.87,
  32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 49.00, 51.91, 55.00, 58.27, 61.74,
  65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47,
  130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94,
  261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,
  523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77,
  1046.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53,
  2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96, 3322.44, 3520.00, 3729.31, 3951.07,
];

// Improved particle system
class TransientParticle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  color: THREE.Color;
  size: number;
  band: 'bass' | 'mid' | 'treble';

  constructor(x: number, y: number, z: number, band: 'bass' | 'mid' | 'treble') {
    this.position = new THREE.Vector3(x, y, z);
    this.band = band;

    // Improved particle physics based on frequency band
    switch(band) {
      case 'bass':
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 5,
            Math.random() * 6 + 4,
            (Math.random() - 0.5) * 5
        );
        this.color = new THREE.Color(1, 0.2, 0.2);
        this.size = 0.5;
        this.maxLife = 1.5;
        break;
      case 'mid':
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 4,
            Math.random() * 5 + 5,
            (Math.random() - 0.5) * 4
        );
        this.color = new THREE.Color(0.2, 1, 0.2);
        this.size = 0.4;
        this.maxLife = 1.3;
        break;
      case 'treble':
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 6,
            Math.random() * 7 + 3,
            (Math.random() - 0.5) * 6
        );
        this.color = new THREE.Color(0.2, 0.2, 1);
        this.size = 0.3;
        this.maxLife = 1.0;
        break;
    }

    this.life = this.maxLife;
  }

  update(delta: number) {
    this.position.add(this.velocity.clone().multiplyScalar(delta));
    this.velocity.y -= 9.8 * delta;
    this.velocity.multiplyScalar(0.98);
    this.life -= delta;
    return this.life > 0;
  }

  getOpacity() {
    return Math.pow(this.life / this.maxLife, 0.5);
  }
}

// Main component
const HarmonicGridV3Component: React.FC<{ audioData: AudioData; config: HarmonicGridV3Settings; globalConfig: GlobalSettings }> = ({ audioData, config }) => {
  const meshRef = useRef<THREE.InstancedMesh>(null!);
  const mirrorMeshRef = useRef<THREE.InstancedMesh>(null!);
  const particleMeshRef = useRef<THREE.InstancedMesh>(null!);
  const dummy = new THREE.Object3D();

  // Grid state
  const gridDataRef = useRef<number[][]>([]);
  const smoothedGridRef = useRef<number[][]>([]);
  const peakGridRef = useRef<number[][]>([]);
  const rippleGridRef = useRef<number[][]>([]);
  const noteTrailsRef = useRef<number[][]>([]);

  // BPM sync state
  const beatPhaseRef = useRef(0);
  const scrollPositionRef = useRef(0);

  // Particle system
  const particlesRef = useRef<TransientParticle[]>([]);
  const maxParticles = 200;

  // Visual effects state
  const flashDecay = useRef(0);
  const rotationAngle = useRef(0);
  const frameCount = useRef(0);
  const lastDominantNote = useRef('');

  // FIXED: Separate color buffers for main and mirror meshes
  const colorBuffer = useMemo(() => new Float32Array(config.gridSize * config.gridSize * 3), [config.gridSize]);
  const mirrorColorBuffer = useMemo(() => new Float32Array(config.gridSize * config.gridSize * 3), [config.gridSize]);
  const particleColorBuffer = useMemo(() => new Float32Array(maxParticles * 3), []);

  // Initialize grids
  useEffect(() => {
    const initGrid = () => Array(config.gridSize).fill(0).map(() => Array(config.gridSize).fill(0));
    gridDataRef.current = initGrid();
    smoothedGridRef.current = initGrid();
    peakGridRef.current = initGrid();
    rippleGridRef.current = initGrid();
    noteTrailsRef.current = initGrid();
  }, [config.gridSize]);

  // Create frequency mapping
  const createFrequencyMapping = (numRows: number, numFreqBins: number, scale: string, sampleRate: number) => {
    const mapping: number[] = [];

    switch (scale) {
      case 'musical': {
        for (let i = 0; i < numRows; i++) {
          const noteIndex = Math.floor((i / numRows) * NOTE_FREQUENCIES.length);
          const noteFreq = NOTE_FREQUENCIES[noteIndex];
          const binIndex = Math.floor((noteFreq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      case 'mel': {
        const melScale = (freq: number) => 2595 * Math.log10(1 + freq / 700);
        const invMelScale = (mel: number) => 700 * (Math.pow(10, mel / 2595) - 1);

        const minMel = melScale(20);
        const maxMel = melScale(20000);

        for (let i = 0; i < numRows; i++) {
          const melValue = minMel + (i / numRows) * (maxMel - minMel);
          const freq = invMelScale(melValue);
          const binIndex = Math.floor((freq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      case 'logarithmic': {
        const minLog = Math.log(20);
        const maxLog = Math.log(20000);

        for (let i = 0; i < numRows; i++) {
          const logValue = minLog + (i / numRows) * (maxLog - minLog);
          const freq = Math.exp(logValue);
          const binIndex = Math.floor((freq / (sampleRate / 2)) * numFreqBins);
          mapping.push(Math.min(binIndex, numFreqBins - 1));
        }
        break;
      }
      default: // linear
        for (let i = 0; i < numRows; i++) {
          const binIndex = Math.floor((i / numRows) * numFreqBins);
          mapping.push(binIndex);
        }
    }

    return mapping;
  };

  const frequencyMapping = useMemo(() =>
          createFrequencyMapping(config.gridSize, audioData.frequencies.length, config.frequencyScale, 44100),
      [config.gridSize, audioData.frequencies.length, config.frequencyScale]
  );

  // Find row for a specific frequency
  const findFrequencyRow = (frequency: number): number => {
    if (frequency <= 0) return -1;

    const sampleRate = 44100;
    const binIndex = Math.floor((frequency / (sampleRate / 2)) * audioData.frequencies.length);

    let closestRow = 0;
    let minDistance = Math.abs(frequencyMapping[0] - binIndex);

    for (let i = 1; i < frequencyMapping.length; i++) {
      const distance = Math.abs(frequencyMapping[i] - binIndex);
      if (distance < minDistance) {
        minDistance = distance;
        closestRow = i;
      }
    }

    return closestRow;
  };

  useFrame((_, delta) => {
    if (!meshRef.current || gridDataRef.current.length !== config.gridSize) return;

    frameCount.current++;
    const { frequencies, transients, dynamicBands, spectralFeatures, melodicFeatures, rhythmicFeatures } = audioData;
    const gridData = gridDataRef.current;
    const smoothedGrid = smoothedGridRef.current;
    const peakGrid = peakGridRef.current;
    const rippleGrid = rippleGridRef.current;
    const noteTrails = noteTrailsRef.current;
    const numRows = config.gridSize;
    const numCols = config.gridSize;

    // BPM-Synced Scrolling
    let scrollAmount = 1;

    if (config.bpmSyncEnabled && rhythmicFeatures.bpm > 0) {
      const currentBeatPhase = rhythmicFeatures.beatPhase;

      switch (config.bpmScrollMode) {
        case 'beat':
          if (currentBeatPhase < beatPhaseRef.current) {
            scrollAmount = 1;
          } else {
            scrollAmount = 0;
          }
          break;

        case 'continuous':
          const beatsPerSecond = rhythmicFeatures.bpm / 60;
          scrollAmount = delta * beatsPerSecond * config.beatDivision;
          scrollPositionRef.current += scrollAmount;

          if (scrollPositionRef.current >= 1) {
            scrollAmount = Math.floor(scrollPositionRef.current);
            scrollPositionRef.current -= scrollAmount;
          } else {
            scrollAmount = 0;
          }
          break;

        case 'quantized':
          const subdivision = 1 / config.beatDivision;
          const currentQuantized = Math.floor(currentBeatPhase / subdivision);
          const lastQuantized = Math.floor(beatPhaseRef.current / subdivision);

          if (currentQuantized !== lastQuantized) {
            scrollAmount = 1;
          } else {
            scrollAmount = 0;
          }
          break;
      }

      beatPhaseRef.current = currentBeatPhase;
    }

    // Scrolling Logic
    if (scrollAmount > 0) {
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols - scrollAmount; col++) {
          gridData[row][col] = gridData[row][col + scrollAmount];
          smoothedGrid[row][col] = smoothedGrid[row][col + scrollAmount];
          peakGrid[row][col] = peakGrid[row][col + scrollAmount] * config.peakDecay;
          noteTrails[row][col] = noteTrails[row][col + scrollAmount] * 0.95;
        }

        for (let s = 0; s < scrollAmount; s++) {
          const col = numCols - scrollAmount + s;
          const freqIndex = frequencyMapping[row];
          let height = (frequencies[freqIndex] || 0) / 255;

          if (height < config.noiseGate) {
            height = 0;
          } else {
            height = (height - config.noiseGate) / (1 - config.noiseGate);
          }

          const freqPosition = row / numRows;
          const centroidBoost = 1 + 0.5 * Math.exp(-Math.pow((freqPosition - spectralFeatures.centroid) * 2, 2));
          height *= centroidBoost;

          gridData[row][col] = height;
          smoothedGrid[row][col] = smoothedGrid[row][col - 1] * config.smoothingFactor +
              height * (1 - config.smoothingFactor);

          if (smoothedGrid[row][col] > peakGrid[row][col]) {
            peakGrid[row][col] = smoothedGrid[row][col];
          }

          noteTrails[row][col] = 0;
        }
      }
    }

    // FIXED: Decay ripples before adding new ones
    if (config.rippleEffect) {
      // Decay existing ripples
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          rippleGrid[row][col] *= config.rippleDecay;
          // Clean up very small values to prevent accumulation
          if (rippleGrid[row][col] < 0.01) {
            rippleGrid[row][col] = 0;
          }
        }
      }

      // Add new ripples on transients
      if (transients.bass || transients.mid || transients.treble) {
        const rippleCol = numCols - 1;

        if (transients.bass) {
          const bassRow = Math.floor(numRows * 0.15);
          rippleGrid[bassRow][rippleCol] = 1.0;

          // IMPROVED: Spawn particles with better visibility
          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
                (rippleCol - numCols / 2) * config.spacing,
                5, // Higher spawn
                (bassRow - numRows / 2) * config.spacing
            );
            for (let i = 0; i < config.particleIntensity * 3; i++) {
              particlesRef.current.push(new TransientParticle(
                  worldPos.x + (Math.random() - 0.5) * 2,
                  worldPos.y,
                  worldPos.z + (Math.random() - 0.5) * 2,
                  'bass'
              ));
            }
          }
        }

        if (transients.mid) {
          const midRow = Math.floor(numRows * 0.5);
          rippleGrid[midRow][rippleCol] = 1.0;

          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
                (rippleCol - numCols / 2) * config.spacing,
                5,
                (midRow - numRows / 2) * config.spacing
            );
            for (let i = 0; i < config.particleIntensity * 3; i++) {
              particlesRef.current.push(new TransientParticle(
                  worldPos.x + (Math.random() - 0.5) * 2,
                  worldPos.y,
                  worldPos.z + (Math.random() - 0.5) * 2,
                  'mid'
              ));
            }
          }
        }

        if (transients.treble) {
          const trebleRow = Math.floor(numRows * 0.85);
          rippleGrid[trebleRow][rippleCol] = 1.0;

          if (config.transientParticles && particlesRef.current.length < maxParticles) {
            const worldPos = new THREE.Vector3(
                (rippleCol - numCols / 2) * config.spacing,
                5,
                (trebleRow - numRows / 2) * config.spacing
            );
            for (let i = 0; i < config.particleIntensity * 3; i++) {
              particlesRef.current.push(new TransientParticle(
                  worldPos.x + (Math.random() - 0.5) * 2,
                  worldPos.y,
                  worldPos.z + (Math.random() - 0.5) * 2,
                  'treble'
              ));
            }
          }
        }
      }

      // Propagate ripples
      const tempRipples = rippleGrid.map(row => [...row]);
      for (let row = 1; row < numRows - 1; row++) {
        for (let col = 1; col < numCols - 1; col++) {
          const spread = 0.15 * config.rippleSpeed;
          const neighbors =
              tempRipples[row - 1][col] + tempRipples[row + 1][col] +
              tempRipples[row][col - 1] + tempRipples[row][col + 1];
          rippleGrid[row][col] += neighbors * spread * 0.25;
          // Cap maximum ripple value
          rippleGrid[row][col] = Math.min(rippleGrid[row][col], 2.0);
        }
      }
    }

    // ENHANCED: Melodic highlighting with better visibility
    if (config.melodicVisualization && melodicFeatures.noteConfidence > 0.3) {
      const fundamentalRow = findFrequencyRow(melodicFeatures.dominantFrequency);

      if (fundamentalRow >= 0 && fundamentalRow < numRows) {
        // Stronger fundamental highlight
        noteTrails[fundamentalRow][numCols - 1] = melodicFeatures.noteConfidence * 2.0;

        if (config.harmonicResonance) {
          // ENHANCED: More visible harmonics
          for (let harmonic = 2; harmonic <= 8; harmonic++) {
            const harmonicRow = findFrequencyRow(melodicFeatures.dominantFrequency * harmonic);
            if (harmonicRow >= 0 && harmonicRow < numRows) {
              const intensity = melodicFeatures.noteConfidence * (1.5 / Math.sqrt(harmonic));
              noteTrails[harmonicRow][numCols - 1] = Math.max(noteTrails[harmonicRow][numCols - 1], intensity);
            }
          }

          // Add subharmonics
          for (let subharmonic = 2; subharmonic <= 4; subharmonic++) {
            const subharmonicRow = findFrequencyRow(melodicFeatures.dominantFrequency / subharmonic);
            if (subharmonicRow >= 0 && subharmonicRow < numRows) {
              const intensity = melodicFeatures.noteConfidence * (1.0 / subharmonic);
              noteTrails[subharmonicRow][numCols - 1] = Math.max(noteTrails[subharmonicRow][numCols - 1], intensity);
            }
          }
        }
      }

      if (melodicFeatures.dominantNote !== lastDominantNote.current) {
        lastDominantNote.current = melodicFeatures.dominantNote;
      }
    }

    // Beat Flash Effect
    if (config.beatFlash && (transients.overall || (rhythmicFeatures.bpm > 0 && rhythmicFeatures.beatPhase < 0.05))) {
      flashDecay.current = config.beatFlashIntensity;
    }
    flashDecay.current = Math.max(0, flashDecay.current - delta * 3);

    // Rotation Effect
    if (config.rotationEffect) {
      const rotationSpeed = rhythmicFeatures.bpm > 0 ?
          (rhythmicFeatures.bpm / 120) * 0.5 : 0.1;
      rotationAngle.current += delta * rotationSpeed;
    }

    // Update Particles
    particlesRef.current = particlesRef.current.filter(particle => particle.update(delta));

    // Update InstancedMesh
    let i = 0;
    const centerX = numCols / 2;
    const centerZ = numRows / 2;
    const base = new THREE.Color(config.baseColor);
    const bass = new THREE.Color(config.bassColor);
    const mid = new THREE.Color(config.midColor);
    const treble = new THREE.Color(config.trebleColor);
    const flash = new THREE.Color(config.beatFlashColor);
    const noteHighlight = new THREE.Color(config.noteHighlightColor);

    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols; col++) {
        const id = i++;

        // Combine height sources with clamping
        const baseHeight = smoothedGrid[row][col];
        const rippleHeight = config.rippleEffect ? Math.min(rippleGrid[row][col], 1.0) : 0;
        const noteTrailHeight = config.melodicVisualization ? noteTrails[row][col] : 0;
        const combinedHeight = baseHeight + rippleHeight * 0.5 + noteTrailHeight * 0.8;

        const height = combinedHeight * config.heightMultiplier;
        const finalHeight = Math.max(0.05, height);

        // Position with optional rotation
        let x = (col - centerX) * config.spacing;
        let z = (row - centerZ) * config.spacing;

        if (config.rotationEffect) {
          const angle = rotationAngle.current;
          const newX = x * Math.cos(angle) - z * Math.sin(angle);
          const newZ = x * Math.sin(angle) + z * Math.cos(angle);
          x = newX;
          z = newZ;
        }

        // ENHANCED: Proper depth effect with Z positioning
        let depthOffset = 0;
        let depthScale = 1;
        if (config.depthEffect) {
          const depthFactor = 1 - (col / numCols);
          depthScale = 0.5 + depthFactor * 0.5;
          depthOffset = (1 - depthFactor) * config.depthIntensity * -5; // Move back in Z
        }

        dummy.position.set(x, finalHeight / 2, z + depthOffset);
        dummy.scale.set(depthScale, finalHeight, depthScale);
        dummy.updateMatrix();
        meshRef.current.setMatrixAt(id, dummy.matrix);

        // Color mapping
        let color = base.clone();
        const freqPosition = row / numRows;

        if (config.chromaColorMode && melodicFeatures.pitchClass) {
          const maxChroma = Math.max(...melodicFeatures.pitchClass);
          const chromaIndex = melodicFeatures.pitchClass.indexOf(maxChroma);
          const hue = chromaIndex / 12;
          color.setHSL(hue, 0.8, 0.5 + combinedHeight * 0.3);
        } else {
          if (freqPosition < 0.3) {
            color.lerp(bass, dynamicBands.bass * 0.8);
          } else if (freqPosition < 0.7) {
            color.lerp(mid, dynamicBands.mid * 0.8);
          } else {
            color.lerp(treble, dynamicBands.treble * 0.8);
          }
        }

        // Note highlighting with enhanced visibility
        if (noteTrailHeight > 0.1) {
          const highlightStrength = Math.min(noteTrailHeight * 2, 1);
          color.lerp(noteHighlight, highlightStrength);
        }

        // Height-based brightness
        const brightness = 0.3 + combinedHeight * 0.7;
        color.multiplyScalar(brightness);

        // Column age fading with depth
        const columnAge = 1 - (col / numCols);
        const ageFading = config.depthEffect ? 0.2 + columnAge * 0.8 : 0.5 + columnAge * 0.5;
        color.multiplyScalar(ageFading);

        // Flash effect
        color.lerp(flash, flashDecay.current);

        // Peak highlighting
        if (peakGrid[row][col] > 0.7) {
          color.multiplyScalar(1.2);
        }

        color.toArray(colorBuffer, id * 3);
      }
    }

    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) {
      meshRef.current.instanceColor.needsUpdate = true;
    }

    // FIXED: Mirror mode with separate mesh and color buffer
    if (config.mirrorMode && mirrorMeshRef.current) {
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          const sourceId = row * numCols + col;

          // Get original matrix
          meshRef.current.getMatrixAt(sourceId, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          // Mirror along Z-axis
          dummy.position.z *= -1;
          dummy.position.z -= config.spacing * 2;
          dummy.updateMatrix();

          mirrorMeshRef.current.setMatrixAt(sourceId, dummy.matrix);

          // Copy color to mirror buffer with dimming
          const r = colorBuffer[sourceId * 3] * 0.6;
          const g = colorBuffer[sourceId * 3 + 1] * 0.6;
          const b = colorBuffer[sourceId * 3 + 2] * 0.6;
          mirrorColorBuffer[sourceId * 3] = r;
          mirrorColorBuffer[sourceId * 3 + 1] = g;
          mirrorColorBuffer[sourceId * 3 + 2] = b;
        }
      }

      mirrorMeshRef.current.instanceMatrix.needsUpdate = true;
      if (mirrorMeshRef.current.instanceColor) {
        mirrorMeshRef.current.instanceColor.needsUpdate = true;
      }
    }

    // IMPROVED: Update particle instances with proper visibility
    if (config.transientParticles && particleMeshRef.current) {
      particlesRef.current.forEach((particle, index) => {
        dummy.position.copy(particle.position);
        const scale = particle.size * particle.life / particle.maxLife;
        dummy.scale.setScalar(scale);
        dummy.updateMatrix();
        particleMeshRef.current.setMatrixAt(index, dummy.matrix);

        const color = particle.color.clone();
        const opacity = particle.getOpacity();
        color.multiplyScalar(opacity);
        color.toArray(particleColorBuffer, index * 3);
      });

      // Clear unused particles
      for (let i = particlesRef.current.length; i < maxParticles; i++) {
        dummy.position.set(0, -1000, 0);
        dummy.scale.setScalar(0);
        dummy.updateMatrix();
        particleMeshRef.current.setMatrixAt(i, dummy.matrix);

        particleColorBuffer[i * 3] = 0;
        particleColorBuffer[i * 3 + 1] = 0;
        particleColorBuffer[i * 3 + 2] = 0;
      }

      particleMeshRef.current.instanceMatrix.needsUpdate = true;
      if (particleMeshRef.current.instanceColor) {
        particleMeshRef.current.instanceColor.needsUpdate = true;
      }
    }
  });

  const instanceCount = config.gridSize * config.gridSize;

  return (
      <group>
        <instancedMesh ref={meshRef} args={[undefined, undefined, instanceCount]}>
          <boxGeometry args={[0.8, 1, 0.8]} />
          <meshStandardMaterial
              metalness={0.3}
              roughness={0.4}
              emissive={new THREE.Color(config.baseColor)}
              emissiveIntensity={0.1}
          />
          <instancedBufferAttribute attach="instanceColor" args={[colorBuffer, 3]} />
        </instancedMesh>

        {config.mirrorMode && (
            <instancedMesh ref={mirrorMeshRef} args={[undefined, undefined, instanceCount]}>
              <boxGeometry args={[0.8, 1, 0.8]} />
              <meshStandardMaterial
                  metalness={0.3}
                  roughness={0.4}
                  emissive={new THREE.Color(config.baseColor)}
                  emissiveIntensity={0.05}
                  transparent
                  opacity={0.7}
              />
              <instancedBufferAttribute attach="instanceColor" args={[mirrorColorBuffer, 3]} />
            </instancedMesh>
        )}

        {config.transientParticles && (
            <instancedMesh ref={particleMeshRef} args={[undefined, undefined, maxParticles]}>
              <sphereGeometry args={[0.2, 12, 8]} />
              <meshBasicMaterial transparent={true} />
              <instancedBufferAttribute attach="instanceColor" args={[particleColorBuffer, 3]} />
            </instancedMesh>
        )}

        {/* Enhanced lighting for better visibility */}
        <pointLight position={[0, 20, 0]} intensity={1} color="#ffffff" />
        <pointLight position={[20, 10, 20]} intensity={0.5} color="#ff8888" />
        <pointLight position={[-20, 10, -20]} intensity={0.5} color="#8888ff" />
      </group>
  );
};

// Scene configuration schema
const schema: SceneSettingsSchema = {
  gridSize: { type: 'slider', label: 'Grid Size', min: 8, max: 64, step: 4 },
  spacing: { type: 'slider', label: 'Spacing', min: 0.5, max: 5, step: 0.1 },
  heightMultiplier: { type: 'slider', label: 'Height Multiplier', min: 1, max: 30, step: 1 },

  // BPM Sync
  bpmSyncEnabled: { type: 'select', label: 'BPM Sync', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  bpmScrollMode: { type: 'select', label: 'BPM Scroll Mode', options: [
      { value: 'beat', label: 'Per Beat' },
      { value: 'continuous', label: 'Continuous' },
      { value: 'quantized', label: 'Quantized' },
    ]},
  beatDivision: { type: 'slider', label: 'Beat Division', min: 1, max: 16, step: 1 },

  // Melodic
  melodicVisualization: { type: 'select', label: 'Melodic Lines', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  harmonicResonance: { type: 'select', label: 'Harmonic Resonance', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  chromaColorMode: { type: 'select', label: 'Chroma Colors', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},

  // Visual
  frequencyScale: { type: 'select', label: 'Frequency Scale', options: [
      { value: 'linear', label: 'Linear' },
      { value: 'logarithmic', label: 'Logarithmic' },
      { value: 'mel', label: 'Mel Scale' },
      { value: 'musical', label: 'Musical Notes' },
    ]},
  smoothingFactor: { type: 'slider', label: 'Smoothing', min: 0, max: 0.95, step: 0.05 },
  noiseGate: { type: 'slider', label: 'Noise Gate', min: 0, max: 0.3, step: 0.01 },
  peakDecay: { type: 'slider', label: 'Peak Decay', min: 0.9, max: 0.99, step: 0.01 },

  // Effects
  rippleEffect: { type: 'select', label: 'Ripple Effect', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  rippleSpeed: { type: 'slider', label: 'Ripple Speed', min: 0.1, max: 2, step: 0.1 },
  rippleDecay: { type: 'slider', label: 'Ripple Decay', min: 0.8, max: 0.99, step: 0.01 },
  beatFlash: { type: 'select', label: 'Beat Flash', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  beatFlashIntensity: { type: 'slider', label: 'Flash Intensity', min: 0.1, max: 1, step: 0.1 },
  transientParticles: { type: 'select', label: 'Transient Particles', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  particleIntensity: { type: 'slider', label: 'Particle Intensity', min: 1, max: 5, step: 1 },

  // Colors
  baseColor: { type: 'color', label: 'Base Color' },
  bassColor: { type: 'color', label: 'Bass Color' },
  midColor: { type: 'color', label: 'Mid Color' },
  trebleColor: { type: 'color', label: 'Treble Color' },
  beatFlashColor: { type: 'color', label: 'Beat Flash Color' },
  noteHighlightColor: { type: 'color', label: 'Note Highlight Color' },

  // Advanced
  depthEffect: { type: 'select', label: 'Depth Effect', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  depthIntensity: { type: 'slider', label: 'Depth Intensity', min: 0.5, max: 3, step: 0.1 },
  mirrorMode: { type: 'select', label: 'Mirror Mode', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
  rotationEffect: { type: 'select', label: 'Rotation Effect', options: [
      { value: 'true', label: 'Enabled' },
      { value: 'false', label: 'Disabled' },
    ]},
};

export const harmonicGridV3Scene: SceneDefinition<HarmonicGridV3Settings> = {
  id: 'harmonicgridv3',
  name: 'Harmonic Grid V3 (Stabilized)',
  component: HarmonicGridV3Component,
  settings: {
    default: {
      gridSize: 32,
      spacing: 1.2,
      heightMultiplier: 15,

      bpmSyncEnabled: true,
      bpmScrollMode: 'continuous',
      beatDivision: 4,

      melodicVisualization: true,
      harmonicResonance: true,
      chromaColorMode: false,

      frequencyScale: 'logarithmic',
      smoothingFactor: 0.85,
      noiseGate: 0.05,
      peakDecay: 0.95,

      rippleEffect: true,
      rippleSpeed: 1.0,
      rippleDecay: 0.92,
      beatFlash: true,
      beatFlashIntensity: 0.7,
      transientParticles: true,
      particleIntensity: 3,

      baseColor: '#00ffff',
      bassColor: '#ff00ff',
      midColor: '#00ff00',
      trebleColor: '#ffff00',
      beatFlashColor: '#ffffff',
      noteHighlightColor: '#ff6600',

      depthEffect: true,
      depthIntensity: 1.5,
      mirrorMode: false,
      rotationEffect: false,
    },
    schema,
  },
};

export default harmonicGridV3Scene;

--- scenes\index.ts ---
import { bars2DScene } from './Bars2D';
import { constellationScene } from './ConstellationVivante';
import { improvedHarmonicGridScene } from './HarmonicGrid';
import { harmonicGridV2Scene } from './HarmonicGridV2';
import { harmonicGridV3Scene } from './HarmonicGridV3';

export const scenes = [
    bars2DScene,
    constellationScene,
    improvedHarmonicGridScene,
    harmonicGridV2Scene,
    harmonicGridV3Scene
];

export const scenesById = Object.fromEntries(scenes.map(scene => [scene.id, scene]));

--- scenes\sceneTypes.ts ---

import type { FC } from 'react';
import type { AudioData } from '../hooks/useAudioAnalyzer';
import type { GlobalSettings } from '../types/config';

// Defines the structure for a single UI control in the settings panel
export interface SceneSettingControl {
  type: 'slider' | 'color' | 'select';
  label: string;
  min?: number;
  max?: number;
  step?: number;
  options?: { value: string; label: string }[];
}

// A map of setting keys to their UI control definitions
export type SceneSettingsSchema = {
  [key: string]: SceneSettingControl;
};

// The complete definition for a scene
export interface SceneDefinition<T> {
  id: string;
  name: string;
  component: FC<{ audioData: AudioData; config: T; globalConfig: GlobalSettings }>;
  settings: {
    default: T;
    schema: SceneSettingsSchema;
  };
}


--- scenes\VisualizationRenderer.tsx ---

import { useConfigStore } from '../store/configStore';
import { scenesById } from './index';
import type { AudioData } from '../hooks/useAudioAnalyzer';

export function VisualizationRenderer({ audioData }: { audioData: AudioData }) {
  const { global, visualization } = useConfigStore();
  const { id, settings } = visualization;

  const SceneComponent = scenesById[id]?.component;

  if (!SceneComponent) {
    return null; // Or a fallback component
  }

  return <SceneComponent audioData={audioData} config={settings} globalConfig={global} />;
}


--- store\configStore.ts ---

import { create } from 'zustand';
import { scenes, scenesById } from '../scenes';
import type { GlobalSettings } from '../types/config';
import { DEFAULT_GLOBAL_SETTINGS } from '../types/config';

interface ConfigState {
  global: GlobalSettings;
  visualization: {
    id: string;
    settings: any;
  };

  // Methods
  updateGlobalSettings: (settings: Partial<GlobalSettings>) => void;
  setVisualization: (id: string) => void;
  updateVisualizationSettings: (settings: any) => void;

  // UI state
  showConfigPanel: boolean;
  toggleConfigPanel: () => void;
  activeConfigTab: 'global' | 'visualization';
  setActiveConfigTab: (tab: 'global' | 'visualization') => void;
}

const defaultScene = scenes[0];

export const useConfigStore = create<ConfigState>((set) => ({
  global: DEFAULT_GLOBAL_SETTINGS,
  visualization: {
    id: defaultScene.id,
    settings: defaultScene.settings.default,
  },

  updateGlobalSettings: (settings) => set((state) => ({ global: { ...state.global, ...settings } })),

  setVisualization: (id) => {
    const scene = scenesById[id];
    if (scene) {
      set({ 
        visualization: {
          id: scene.id,
          settings: scene.settings.default,
        }
      });
    }
  },

  updateVisualizationSettings: (settings) => set((state) => ({
    visualization: {
      ...state.visualization,
      settings: { ...state.visualization.settings, ...settings },
    },
  })),

  // UI state
  showConfigPanel: false,
  toggleConfigPanel: () => set((state) => ({ showConfigPanel: !state.showConfigPanel })),
  activeConfigTab: 'global',
  setActiveConfigTab: (tab) => set({ activeConfigTab: tab }),
}));


--- styles\App.css ---
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


--- styles\index.css ---
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


--- types\config.ts ---
export type ReactivityCurve = "linear" | "easeOutQuad" | "exponential";
export type AudioLink = "volume" | "bass" | "mids" | "treble" | "none";
export type ColorMode = "static" | "gradient" | "audio-reactive" | "frequency" | "rainbow" | "single";
export type CameraMode = "orbit" | "follow" | "static";
export type ShapeType = "cube" | "sphere" | "icosahedron" | "custom";
export type GridLayout = "plane" | "cylinder" | "spiral" | "helix";
export type ConstellationFormation = "random" | "sphere" | "spiral" | "dnahelix" | "cube" | "torus";
export type ConnectionType = "proximity" | "frequency" | "beat-sync" | "formation-based";
export type VisualizationMode = "bars2d" | "sphere2d" | "sphere3d" | "tunnelsdf" | "wave" | "grid2d" | "constellation" | "pulsargrid";

// 1. Global Settings
export interface GlobalSettings {
  name: string;
  bpmSync: boolean;
  volumeMultiplier: number;
  fftSmoothing: number; // 0 ‚Üí 1
  reactivityCurve: ReactivityCurve;
  cameraFOV: number;
  cameraOrbitSpeed: number;
  cameraMode: CameraMode;
  bgColor: string; // "#hex" format
}

// Default configurations
export const DEFAULT_GLOBAL_SETTINGS: GlobalSettings = {
  name: "Default Scene",
  bpmSync: false,
  volumeMultiplier: 1.0,
  fftSmoothing: 0.8,
  reactivityCurve: "easeOutQuad",
  cameraFOV: 60,
  cameraOrbitSpeed: 0.05,
  cameraMode: "orbit",
  bgColor: "#0a0a0a"
};

--- utils\audioUtils.ts ---
import * as ConfigTypes from '../types/config'
import type {AudioData} from '../hooks/useAudioAnalyzer'
import type {AudioLink, ReactivityCurve} from '../types/config'

// Reactivity curve functions
export function applyReactivityCurve(value: number, curve: ConfigTypes.ReactivityCurve): number {
  switch (curve) {
    case 'linear':
      return value
    case 'easeOutQuad':
      return 1 - (1 - value) * (1 - value)
    case 'exponential':
      return value * value * value
    default:
      return value
  }
}

// Get audio value by link type
export function getAudioValue(audioData: AudioData, link: ConfigTypes.AudioLink): number {
  switch (link) {
    case 'volume':
      return audioData.volume
    case 'bass':
      return audioData.bands.bass
    case 'mids':
      return audioData.bands.mid
    case 'treble':
      return audioData.bands.treble
    case 'none':
      return 0
    default:
      return 0
  }
}

// Apply audio-reactive scaling with configuration
export function calculateAudioScale(
  audioData: AudioData,
  baseScale: number,
  audioLink: ConfigTypes.AudioLink,
  multiplier: number,
  curve: ConfigTypes.ReactivityCurve,
  volumeMultiplier: number = 1
): number {
  if (audioLink === 'none') return baseScale
  
  let audioValue = getAudioValue(audioData, audioLink) * volumeMultiplier
  audioValue = Math.min(audioValue, 1) // Clamp to prevent extreme values
  
  const curvedValue = applyReactivityCurve(audioValue, curve)
  
  return baseScale + (curvedValue * multiplier)
}

// Calculate audio-reactive color with HSL
export function calculateAudioColor(
  audioData: AudioData,
  baseHue: number,
  saturation: number = 0.8,
  lightness: number = 0.5,
  audioLink: AudioLink = 'volume',
  curve: ReactivityCurve = 'linear'
): [number, number, number] {
  const audioValue = getAudioValue(audioData, audioLink)
  const curvedValue = applyReactivityCurve(audioValue, curve)
  
  const hue = (baseHue + curvedValue * 0.3) % 1 // Shift hue based on audio
  const sat = Math.min(saturation + curvedValue * 0.2, 1)
  const light = Math.min(lightness + curvedValue * 0.3, 0.9)
  
  return [hue, sat, light]
}

// Smooth interpolation with configurable factor
export function smoothLerp(current: number, target: number, factor: number): number {
  return current + (target - current) * factor
}

// BPM sync utilities (for future use)
export function getBPM(audioData: AudioData): number {
  // Simplified BPM detection - can be enhanced later
  return audioData.beat ? 120 : 0 // Placeholder
}

export function syncToBPM(time: number, bpm: number): number {
  if (bpm === 0) return time
  const beatDuration = 60 / bpm
  return (time % beatDuration) / beatDuration
}

--- utils\BPMDetector.ts ---
// BPM Detection Module for AuraSync - Refactored with Autocorrelation
import type { AudioData } from '../hooks/useAudioAnalyzer';

// Fonction pour calculer l'autocorr√©lation d'un signal (ODF buffer)
function autocorrelation(buffer: number[]): number[] {
    const acf = new Array(buffer.length).fill(0);
    for (let lag = 0; lag < buffer.length; lag++) {
        for (let i = 0; i < buffer.length - lag; i++) {
            acf[lag] += buffer[i] * buffer[i + lag];
        }
    }
    return acf;
}

export class BPMDetector {
    private bpmHistory: number[] = [];
    private readonly historySize = 15;
    private readonly minBPM = 70;
    private readonly maxBPM = 190;

    // NEW: Store ACF and bestLag for confidence calculation
    private lastACF: number[] | null = null;
    private lastBestLag: number = 0;

    // NEW: Ignore transient confidence drops
    private confidenceHistory: number[] = [];
    private readonly confidenceHistorySize = 10;

    // Pas besoin de garder un √©tat interne complexe ici, la logique est plus directe.

    public detectBPM(odfHistory: number[], sampleRate: number): number {
        if (odfHistory.length < 128) { // On attend d'avoir assez de donn√©es
            return this.getStableBPM();
        }

        // 1. Calculer l'autocorr√©lation sur l'historique de l'ODF
        const acf = autocorrelation(odfHistory);

        // 2. D√©finir la plage de recherche en "lags" (d√©calages) - FIXED calculation
        const minLag = Math.floor(sampleRate * 60 / this.maxBPM);
        const maxLag = Math.ceil(sampleRate * 60 / this.minBPM);

        // 3. Trouver le pic de corr√©lation dans la plage plausible - IMPROVED peak detection
        let maxCorrelation = -Infinity;
        let bestLag = 0;

        for (let lag = minLag; lag <= maxLag && lag < acf.length; lag++) {
            // V√©rifier que c'est un vrai pic local
            if (lag > 0 && lag < acf.length - 1) {
                if (acf[lag] > acf[lag - 1] && acf[lag] > acf[lag + 1] && acf[lag] > maxCorrelation) {
                    maxCorrelation = acf[lag];
                    bestLag = lag;
                }
            }
        }

        // Store ACF and bestLag for confidence calculation
        this.lastACF = acf;
        this.lastBestLag = bestLag;

        // 4. Convertir le meilleur lag en BPM
        if (bestLag > 0) {
            const calculatedBPM = 60 / (bestLag / sampleRate);

            // 5. Ajouter √† l'historique pour stabilisation
            this.bpmHistory.push(calculatedBPM);
            if (this.bpmHistory.length > this.historySize) {
                this.bpmHistory.shift();
            }
        }

        // 6. Retourner une valeur stable
        return this.getStableBPM();
    }

    // NEW: Calculate peak prominence for better confidence metrics
    private calculatePeakProminence(acf: number[], bestLag: number): number {
        const peakValue = acf[bestLag];
        // Trouver le 2e pic dans une fen√™tre √©loign√©e
        let secondPeak = 0;
        for (let lag = bestLag + 10; lag < acf.length; lag++) {
            secondPeak = Math.max(secondPeak, acf[lag]);
        }
        return peakValue / (secondPeak || 1);
    }

    private getStableBPM(): number {
        if (this.bpmHistory.length < 5) return 0;

        // Utiliser la m√©diane pour la stabilit√©
        const sorted = [...this.bpmHistory].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);

        return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    public getConfidence(): number {
        if (this.bpmHistory.length < 5) return 0;

        // Calculate current confidence
        const mean = this.bpmHistory.reduce((a, b) => a + b, 0) / this.bpmHistory.length;
        const stdDev = Math.sqrt(this.bpmHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / this.bpmHistory.length);
        const stabilityFactor = Math.max(0, 1 - (stdDev / (mean * 0.08)));

        let currentConfidence = stabilityFactor;

        // Add peak prominence if available
        if (this.lastACF && this.lastBestLag > 0) {
            const prominence = this.calculatePeakProminence(this.lastACF, this.lastBestLag);
            const prominenceFactor = Math.min(prominence / 3, 1);
            currentConfidence = (prominenceFactor + stabilityFactor) / 2;
        }

        // NEW: Smooth confidence to avoid transient drops
        this.confidenceHistory.push(currentConfidence);
        if (this.confidenceHistory.length > this.confidenceHistorySize) {
            this.confidenceHistory.shift();
        }

        // Return median of recent confidences
        const sorted = [...this.confidenceHistory].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    // Ces fonctions restent utiles pour la synchronisation visuelle
    getBeatPhase(currentTime: number, bpm: number, lastBeatTime: number): number {
        if (bpm === 0 || lastBeatTime === 0) return 0;
        const beatDuration = 60 / bpm;
        const timeSinceLastBeat = currentTime - lastBeatTime;
        return (timeSinceLastBeat % beatDuration) / beatDuration;
    }

    // Predict next beat time
    getNextBeatTime(currentTime: number, bpm: number): number {
        if (bpm === 0) return currentTime + 1;

        const beatDuration = 60 / bpm;
        const phase = this.getBeatPhase(currentTime, bpm, 0);
        return currentTime + (1 - phase) * beatDuration;
    }
}

// Hook for using BPM detection in components
import { useRef, useEffect, useState } from 'react';

export function useBPMDetection(audioData: AudioData) {
    const detectorRef = useRef(new BPMDetector());
    const [bpmInfo, setBPMInfo] = useState({
        bpm: 0,
        phase: 0,
        confidence: 0
    });

    useEffect(() => {
        const updateBPM = () => {
            const currentTime = performance.now() / 1000;
            // Note: Cette partie sera adapt√©e quand useAudioAnalyzer sera modifi√©
            // pour fournir l'historique ODF au lieu de l'AudioData compl√®te
            const bpm = 0; // Temporaire
            const phase = detectorRef.current.getBeatPhase(currentTime, bpm, 0);

            setBPMInfo({
                bpm: Math.round(bpm),
                phase,
                confidence: bpm > 0 ? detectorRef.current.getConfidence() : 0
            });
        };

        updateBPM();
    }, [audioData]);

    return bpmInfo;
}

// Utility functions for BPM-synced animations
export const BPMSync = {
    // Get a value that oscillates with the beat (0-1-0)
    sineWave: (phase: number): number => {
        return Math.sin(phase * Math.PI * 2) * 0.5 + 0.5;
    },

    // Get a sawtooth wave (0-1 ramp)
    sawtooth: (phase: number): number => {
        return phase;
    },

    // Get a square wave (0 or 1)
    square: (phase: number): number => {
        return phase < 0.5 ? 0 : 1;
    },

    // Get a pulse at beat start
    pulse: (phase: number, width: number = 0.1): number => {
        return phase < width ? 1 - (phase / width) : 0;
    },

    // Quantize time to nearest beat subdivision
    quantize: (phase: number, subdivisions: number): number => {
        return Math.floor(phase * subdivisions) / subdivisions;
    }
};

--- utils\melFilterbank.ts ---
/**
 * Mel Filterbank and Robust ODF Implementation for AuraSync
 * Based on the correction guide for BPM detection system
 */

/**
 * Cr√©e une banque de filtres triangulaires espac√©s sur l'√©chelle Mel.
 * @param fftSize La taille de la FFT (par ex. 2048).
 * @param melBands Le nombre de bandes Mel √† cr√©er (par ex. 40).
 * @param sampleRate La fr√©quence d'√©chantillonnage de l'audio (par ex. 44100).
 * @returns Une matrice de filtres.
 */
export function createMelFilterbank(fftSize: number, melBands: number, sampleRate: number): number[][] {
    const toMel = (hz: number): number => 1127 * Math.log(1 + hz / 700);
    const toHz = (mel: number): number => 700 * (Math.exp(mel / 1127) - 1);

    const maxMel = toMel(sampleRate / 2);
    const minMel = toMel(30); // Fr√©quence minimale
    const melStep = (maxMel - minMel) / (melBands + 1);

    const melCenters: number[] = [];
    for (let i = 0; i < melBands + 2; i++) {
        melCenters.push(minMel + i * melStep);
    }

    const hzPoints = melCenters.map(toHz);
    const fftBinPoints = hzPoints.map(hz => Math.floor((fftSize + 1) * hz / sampleRate));

    const filterbank: number[][] = [];
    for (let i = 0; i < melBands; i++) {
        const filter = new Array(fftSize / 2 + 1).fill(0);
        const start = fftBinPoints[i];
        const center = fftBinPoints[i + 1];
        const end = fftBinPoints[i + 2];

        for (let j = start; j < center; j++) {
            filter[j] = (j - start) / (center - start);
        }
        for (let j = center; j < end; j++) {
            filter[j] = (end - j) / (end - center);
        }
        filterbank.push(filter);
    }
    return filterbank;
}

/**
 * Calcule une Fonction de D√©tection d'Onset (ODF) robuste en utilisant une approche multi-bandes.
 * @param fftMagnitudes Le tableau des magnitudes de la FFT pour la trame actuelle.
 * @param prevMelEnergies Le tableau des √©nergies Mel de la trame pr√©c√©dente.
 * @param melFilterbank La matrice de la banque de filtres Mel.
 * @param melBands Le nombre de bandes Mel.
 * @returns La valeur de l'ODF pour la trame courante.
 */
export function calculateRobustODF(
    fftMagnitudes: Uint8Array,
    prevMelEnergies: Float32Array,
    melFilterbank: number[][],
    melBands: number
): number {
    const melEnergies = new Float32Array(melBands).fill(0);

    // 1. Appliquer la banque de filtres pour obtenir les √©nergies par bande Mel
    for (let i = 0; i < melBands; i++) {
        for (let j = 0; j < fftMagnitudes.length; j++) {
            // Normaliser la magnitude de la FFT (0-255) en 0-1
            const normalizedMagnitude = fftMagnitudes[j] / 255;
            melEnergies[i] += melFilterbank[i][j] * normalizedMagnitude;
        }
    }

    // 2. Calculer le flux spectral (diff√©rence positive) pour chaque bande
    const bandFluxes: number[] = [];
    for (let i = 0; i < melBands; i++) {
        const flux = melEnergies[i] - prevMelEnergies[i];
        // Redressement demi-onde : ne conserver que les augmentations d'√©nergie
        if (flux > 0) {
            bandFluxes.push(flux);
        }
    }

    // 3. Mettre √† jour l'historique des √©nergies Mel pour la prochaine trame
    prevMelEnergies.set(melEnergies);

    // 4. Agr√©ger les flux de chaque bande avec la m√©diane pour une robustesse maximale
    // La m√©diane garantit qu'un pic doit se produire dans plus de la moiti√© des bandes
    // pour √™tre refl√©t√© dans l'ODF finale.
    if (bandFluxes.length === 0) return 0;

    const sortedFluxes = bandFluxes.sort((a, b) => a - b);
    const mid = Math.floor(sortedFluxes.length / 2);
    const medianFlux = sortedFluxes.length % 2 !== 0
        ? sortedFluxes[mid]
        : (sortedFluxes[mid - 1] + sortedFluxes[mid]) / 2;

    // Retourner la valeur de l'ODF, potentiellement mise √† l'√©chelle pour une meilleure plage dynamique
    return medianFlux;
}

/**
 * Helper pour calculer la m√©diane d'un tableau de nombres
 */
export function calculateMedian(arr: number[]): number {
    if (arr.length === 0) return 0;
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
}


--- utils\timbreAnalyzer.ts ---
// Timbre Analysis Utilities for AuraSync
// Combines pitch detection with spectral features for comprehensive musical analysis

import type { MelodicFeatures, SpectralFeatures } from '../hooks/useAudioAnalyzer';

export interface TimbreProfile {
  brightness: number; // 0-1, based on spectral centroid
  warmth: number; // 0-1, inverse of brightness
  richness: number; // 0-1, based on harmonic content
  clarity: number; // 0-1, based on spectral spread (inverse)
  attack: number; // 0-1, based on spectral flux
  dominantChroma: number; // 0-11, strongest pitch class
  harmonicComplexity: number; // 0-1, measure of harmonic complexity
}

export interface MusicalContext {
  notePresent: boolean;
  noteStability: number; // 0-1, how stable the detected note is
  key: string; // Detected key based on chroma
  mode: 'major' | 'minor' | 'unknown';
  tension: number; // 0-1, harmonic tension measure
}

// Major and minor key profiles for key detection
const MAJOR_PROFILE = [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88];
const MINOR_PROFILE = [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17];

export class TimbreAnalyzer {
  private noteHistory: string[] = [];
  private chromaHistory: number[][] = [];
  private readonly historySize = 30; // About 1 second at 30fps

  public analyzeTimbre(melodic: MelodicFeatures, spectral: SpectralFeatures): TimbreProfile {
    // Calculate brightness (0-1)
    const brightness = spectral.centroid;

    // Warmth is inverse of brightness
    const warmth = 1 - brightness;

    // Richness based on harmonic content
    const richness = melodic.harmonicContent;

    // Clarity is inverse of spectral spread (less spread = more clarity)
    const clarity = Math.max(0, 1 - spectral.spread);

    // Attack based on spectral flux (how quickly spectrum changes)
    const attack = spectral.flux;

    // Find dominant chroma (strongest pitch class)
    let maxChroma = 0;
    let dominantChroma = 0;
    for (let i = 0; i < melodic.pitchClass.length; i++) {
      if (melodic.pitchClass[i] > maxChroma) {
        maxChroma = melodic.pitchClass[i];
        dominantChroma = i;
      }
    }

    // Calculate harmonic complexity as variance in chroma vector
    const chromaMean = melodic.pitchClass.reduce((a, b) => a + b, 0) / 12;
    const chromaVariance = melodic.pitchClass.reduce((sum, val) => sum + Math.pow(val - chromaMean, 2), 0) / 12;
    const harmonicComplexity = Math.min(1, chromaVariance * 10); // Scale to 0-1

    return {
      brightness,
      warmth,
      richness,
      clarity,
      attack,
      dominantChroma,
      harmonicComplexity
    };
  }

  public analyzeMusicalContext(melodic: MelodicFeatures, timbre: TimbreProfile): MusicalContext {
    // Track note history for stability analysis
    if (melodic.dominantNote !== 'N/A') {
      this.noteHistory.push(melodic.dominantNote);
      if (this.noteHistory.length > this.historySize) {
        this.noteHistory.shift();
      }
    }

    // Track chroma history
    this.chromaHistory.push([...melodic.pitchClass]);
    if (this.chromaHistory.length > this.historySize) {
      this.chromaHistory.shift();
    }

    // Calculate note stability
    const notePresent = melodic.noteConfidence > 0.3 && melodic.dominantNote !== 'N/A';
    let noteStability = 0;

    if (notePresent && this.noteHistory.length > 5) {
      const recentNotes = this.noteHistory.slice(-10);
      const mostCommonNote = this.getMostCommon(recentNotes);
      const stability = recentNotes.filter(note => note === mostCommonNote).length / recentNotes.length;
      noteStability = stability;
    }

    // Key detection using Krumhansl-Schmuckler algorithm
    const { key, mode } = this.detectKey(melodic.pitchClass);

    // Calculate harmonic tension based on dissonance
    const tension = this.calculateTension(melodic.pitchClass, timbre.harmonicComplexity);

    return {
      notePresent,
      noteStability,
      key,
      mode,
      tension
    };
  }

  private getMostCommon(arr: string[]): string {
    const counts: { [key: string]: number } = {};
    for (const item of arr) {
      counts[item] = (counts[item] || 0) + 1;
    }
    return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
  }

  private detectKey(chroma: number[]): { key: string; mode: 'major' | 'minor' | 'unknown'; correlation: number } {
    const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    let bestKey = 'C';
    let bestMode: 'major' | 'minor' | 'unknown' = 'unknown';
    let bestCorrelation = -1;

    // Test all 24 keys (12 major + 12 minor)
    for (let i = 0; i < 12; i++) {
      // Test major
      const majorCorr = this.correlate(chroma, this.rotateArray(MAJOR_PROFILE, i));
      if (majorCorr > bestCorrelation) {
        bestCorrelation = majorCorr;
        bestKey = keys[i];
        bestMode = 'major';
      }

      // Test minor
      const minorCorr = this.correlate(chroma, this.rotateArray(MINOR_PROFILE, i));
      if (minorCorr > bestCorrelation) {
        bestCorrelation = minorCorr;
        bestKey = keys[i];
        bestMode = 'minor';
      }
    }

    // If correlation is too low, mark as unknown
    if (bestCorrelation < 0.6) {
      bestMode = 'unknown';
    }

    return { key: bestKey, mode: bestMode, correlation: bestCorrelation };
  }

  private correlate(a: number[], b: number[]): number {
    const n = a.length;
    let sumA = 0, sumB = 0, sumAB = 0, sumA2 = 0, sumB2 = 0;

    for (let i = 0; i < n; i++) {
      sumA += a[i];
      sumB += b[i];
      sumAB += a[i] * b[i];
      sumA2 += a[i] * a[i];
      sumB2 += b[i] * b[i];
    }

    const numerator = n * sumAB - sumA * sumB;
    const denominator = Math.sqrt((n * sumA2 - sumA * sumA) * (n * sumB2 - sumB * sumB));

    return denominator === 0 ? 0 : numerator / denominator;
  }

  private rotateArray(arr: number[], steps: number): number[] {
    const n = arr.length;
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
      result[i] = arr[(i + steps) % n];
    }
    return result;
  }

  private calculateTension(chroma: number[], complexity: number): number {
    // Simple tension calculation based on dissonant intervals
    const dissonantIntervals = [1, 6, 10]; // Minor 2nd, tritone, minor 7th (in semitones)
    let tension = 0;

    for (let i = 0; i < chroma.length; i++) {
      for (let j = 0; j < dissonantIntervals.length; j++) {
        const interval = dissonantIntervals[j];
        const targetIndex = (i + interval) % 12;
        tension += chroma[i] * chroma[targetIndex];
      }
    }

    // Combine with harmonic complexity
    return Math.min(1, (tension + complexity) / 2);
  }
}

// Helper functions for visualization
export const TimbreUtils = {
  // Get color based on timbre characteristics
  getTimbreColor: (timbre: TimbreProfile): string => {
    const hue = timbre.dominantChroma * 30; // Map 0-11 to 0-330 degrees
    const saturation = Math.round(timbre.richness * 100);
    const lightness = Math.round(50 + timbre.brightness * 30);
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  },

  // Get visualization parameters based on musical context
  getVisualParams: (context: MusicalContext, timbre: TimbreProfile) => ({
    stability: context.noteStability,
    energy: timbre.attack,
    warmth: timbre.warmth,
    complexity: timbre.harmonicComplexity,
    tension: context.tension,
    mode: context.mode
  }),

  // Convert chroma to visual intensity for each note
  getChromaVisualization: (chroma: number[]) => {
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    return noteNames.map((note, index) => ({
      note,
      intensity: chroma[index],
      angle: (index / 12) * 360 // For circular visualizations
    }));
  }
};


--- utils\YINPitchDetector.ts ---
// YIN Algorithm Implementation for Superior Pitch Detection
// Based on the YIN fundamental frequency estimator by Alain de Cheveign√© and Hideki Kawahara

export class YINPitchDetector {
  private sampleRate: number;
  private bufferSize: number;
  private threshold: number;
  private yinBuffer: Float32Array;
  private adaptiveThreshold: number; // Add adaptive threshold property

  constructor(sampleRate: number = 44100, bufferSize: number = 2048, threshold: number = 0.1) {
    this.sampleRate = sampleRate;
    this.bufferSize = bufferSize;
    this.threshold = threshold;
    this.yinBuffer = new Float32Array(bufferSize / 2);
    this.adaptiveThreshold = threshold; // Initialize adaptive threshold
  }

  // Main YIN algorithm
  public detectPitch(audioBuffer: Float32Array): { frequency: number; probability: number } {
    if (audioBuffer.length < this.bufferSize) {
      return { frequency: 0, probability: 0 };
    }

    // Step 1: Calculate the difference function
    this.calculateDifferenceFunction(audioBuffer);

    // Step 2: Calculate the cumulative mean normalized difference function
    this.calculateCumulativeMeanNormalizedDifference();

    // Step 3: Get the absolute threshold
    const tauEstimate = this.getAbsoluteThreshold();

    if (tauEstimate === -1) {
      return { frequency: 0, probability: 0 };
    }

    // Step 4: Parabolic interpolation
    const betterTau = this.parabolicInterpolation(tauEstimate);

    // Calculate frequency and probability
    const frequency = this.sampleRate / betterTau;
    const probability = 1 - this.yinBuffer[tauEstimate];

    return {
      frequency: frequency,
      probability: Math.max(0, Math.min(1, probability))
    };
  }

  // Step 1: Calculate difference function
  private calculateDifferenceFunction(audioBuffer: Float32Array): void {
    let delta: number;
    let sum: number;

    for (let tau = 0; tau < this.yinBuffer.length; tau++) {
      sum = 0;
      for (let i = 0; i < this.yinBuffer.length; i++) {
        delta = audioBuffer[i] - audioBuffer[i + tau];
        sum += delta * delta;
      }
      this.yinBuffer[tau] = sum;
    }
  }

  // Step 2: Calculate cumulative mean normalized difference function
  private calculateCumulativeMeanNormalizedDifference(): void {
    let sum = 0;
    this.yinBuffer[0] = 1;

    for (let tau = 1; tau < this.yinBuffer.length; tau++) {
      sum += this.yinBuffer[tau];
      this.yinBuffer[tau] *= tau / sum;
    }
  }

  // Step 3: Search for absolute threshold
  private getAbsoluteThreshold(): number {
    const threshold = this.adaptiveThreshold || this.threshold;
    let tau = 2; // Start from tau = 2 to avoid fundamental frequency too high
    let minTau = -1;
    let minVal = 1000;

    // Find the first local minimum below threshold
    while (tau < this.yinBuffer.length) {
      if (this.yinBuffer[tau] < threshold) {
        while (tau + 1 < this.yinBuffer.length && this.yinBuffer[tau + 1] < this.yinBuffer[tau]) {
          tau++;
        }
        return tau;
      }

      // Keep track of global minimum in case no value below threshold is found
      if (this.yinBuffer[tau] < minVal) {
        minVal = this.yinBuffer[tau];
        minTau = tau;
      }

      tau++;
    }

    // If no value below threshold found, use global minimum if it's reasonable
    if (minTau !== -1 && minVal < 0.8) {
      return minTau;
    }

    return -1;
  }

  // Step 4: Parabolic interpolation for better precision
  private parabolicInterpolation(tauEstimate: number): number {
    let betterTau: number;
    let x0: number, x2: number;

    if (tauEstimate < 1) {
      x0 = tauEstimate;
    } else {
      x0 = tauEstimate - 1;
    }

    if (tauEstimate + 1 < this.yinBuffer.length) {
      x2 = tauEstimate + 1;
    } else {
      x2 = tauEstimate;
    }

    if (x0 === tauEstimate) {
      if (this.yinBuffer[tauEstimate] <= this.yinBuffer[x2]) {
        betterTau = tauEstimate;
      } else {
        betterTau = x2;
      }
    } else if (x2 === tauEstimate) {
      if (this.yinBuffer[tauEstimate] <= this.yinBuffer[x0]) {
        betterTau = tauEstimate;
      } else {
        betterTau = x0;
      }
    } else {
      const s0 = this.yinBuffer[x0];
      const s1 = this.yinBuffer[tauEstimate];
      const s2 = this.yinBuffer[x2];

      betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
    }

    return betterTau;
  }

  // Update sample rate if audio context changes
  public updateSampleRate(sampleRate: number): void {
    this.sampleRate = sampleRate;
  }

  // Adjust threshold for sensitivity
  public setThreshold(threshold: number): void {
    this.threshold = Math.max(0.01, Math.min(0.99, threshold));
    this.adaptiveThreshold = this.threshold; // Update adaptive threshold
  }

  // Add new method for dynamic threshold adjustment
  public updateThreshold(spectralFlux: number, volume: number): void {
    // Lower threshold for cleaner signals
    const signalQuality = Math.min(1, volume * (1 - spectralFlux));
    this.adaptiveThreshold = 0.05 + (0.15 * (1 - signalQuality));
  }
}


